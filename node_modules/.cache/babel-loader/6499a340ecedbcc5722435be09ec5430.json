{"ast":null,"code":"import _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\nimport { isNodeCryptoAvailable } from './cryptoUtils';\nexport var Ripemd160PolyfillDigest = /*#__PURE__*/function () {\n  function Ripemd160PolyfillDigest() {\n    _classCallCheck(this, Ripemd160PolyfillDigest);\n  }\n\n  _createClass(Ripemd160PolyfillDigest, [{\n    key: \"digest\",\n    value: function digest(data) {\n      var instance = new Ripemd160Polyfill();\n      instance.update(data);\n      var hash = instance.digest();\n\n      if (Array.isArray(hash)) {\n        return Buffer.from(hash);\n      } else {\n        return Buffer.from(hash.buffer);\n      }\n    }\n  }]);\n\n  return Ripemd160PolyfillDigest;\n}();\nexport var NodeCryptoRipemd160Digest = /*#__PURE__*/function () {\n  function NodeCryptoRipemd160Digest(nodeCryptoCreateHash) {\n    _classCallCheck(this, NodeCryptoRipemd160Digest);\n\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  _createClass(NodeCryptoRipemd160Digest, [{\n    key: \"digest\",\n    value: function digest(data) {\n      try {\n        return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n      } catch (error) {\n        try {\n          return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n        } catch (_err) {\n          console.log(error);\n          console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n          var polyfill = new Ripemd160PolyfillDigest();\n          return polyfill.digest(data);\n        }\n      }\n    }\n  }]);\n\n  return NodeCryptoRipemd160Digest;\n}();\nexport function createHashRipemd160() {\n  var nodeCryptoCreateHash = isNodeCryptoAvailable(function (nodeCrypto) {\n    if (typeof nodeCrypto.createHash === 'function') {\n      return nodeCrypto.createHash;\n    }\n\n    return false;\n  });\n\n  if (nodeCryptoCreateHash) {\n    return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n  } else {\n    return new Ripemd160PolyfillDigest();\n  }\n}\nexport function hashRipemd160(data) {\n  var hash = createHashRipemd160();\n  return hash.digest(data);\n}","map":{"version":3,"sources":["../../src/hashRipemd160.ts"],"names":[],"mappings":";;AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,OAAO,iBAAP,MAA8B,eAA9B;AACA,SAAS,qBAAT,QAAsC,eAAtC;AAQA,WAAa,uBAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,WACE,gBAAO,IAAP,EAAmB;AACjB,UAAM,QAAQ,GAAG,IAAI,iBAAJ,EAAjB;AACA,MAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB;AACA,UAAM,IAAI,GAAG,QAAQ,CAAC,MAAT,EAAb;;AACA,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,eAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAP;AACD,OAFD,MAEO;AACL,eAAO,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,MAAjB,CAAP;AACD;AACF;AAVH;;AAAA;AAAA;AAaA,WAAa,yBAAb;AAGE,qCAAY,oBAAZ,EAAsD;AAAA;;AACpD,SAAK,oBAAL,GAA4B,oBAA5B;AACD;;AALH;AAAA;AAAA,WAOE,gBAAO,IAAP,EAAmB;AACjB,UAAI;AACF,eAAO,KAAK,oBAAL,CAA0B,QAA1B,EAAoC,MAApC,CAA2C,IAA3C,EAAiD,MAAjD,EAAP;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd,YAAI;AACF,iBAAO,KAAK,oBAAL,CAA0B,WAA1B,EAAuC,MAAvC,CAA8C,IAA9C,EAAoD,MAApD,EAAP;AACD,SAFD,CAEE,OAAO,IAAP,EAAa;AACb,UAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,UAAA,OAAO,CAAC,GAAR,CACE,2GADF;AAGA,cAAM,QAAQ,GAAG,IAAI,uBAAJ,EAAjB;AACA,iBAAO,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAP;AACD;AACF;AACF;AAtBH;;AAAA;AAAA;AAyBA,OAAM,SAAU,mBAAV,GAA6B;AACjC,MAAM,oBAAoB,GAAG,qBAAqB,CAAC,UAAA,UAAU,EAAG;AAC9D,QAAI,OAAO,UAAU,CAAC,UAAlB,KAAiC,UAArC,EAAiD;AAC/C,aAAO,UAAU,CAAC,UAAlB;AACD;;AACD,WAAO,KAAP;AACD,GALiD,CAAlD;;AAMA,MAAI,oBAAJ,EAA0B;AACxB,WAAO,IAAI,yBAAJ,CAA8B,oBAA9B,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI,uBAAJ,EAAP;AACD;AACF;AAED,OAAM,SAAU,aAAV,CAAwB,IAAxB,EAAoC;AACxC,MAAM,IAAI,GAAG,mBAAmB,EAAhC;AACA,SAAO,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAP;AACD","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\nimport { isNodeCryptoAvailable } from './cryptoUtils';\nexport class Ripemd160PolyfillDigest {\n    digest(data) {\n        const instance = new Ripemd160Polyfill();\n        instance.update(data);\n        const hash = instance.digest();\n        if (Array.isArray(hash)) {\n            return Buffer.from(hash);\n        }\n        else {\n            return Buffer.from(hash.buffer);\n        }\n    }\n}\nexport class NodeCryptoRipemd160Digest {\n    constructor(nodeCryptoCreateHash) {\n        this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n    }\n    digest(data) {\n        try {\n            return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n        }\n        catch (error) {\n            try {\n                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n            }\n            catch (_err) {\n                console.log(error);\n                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n                const polyfill = new Ripemd160PolyfillDigest();\n                return polyfill.digest(data);\n            }\n        }\n    }\n}\nexport function createHashRipemd160() {\n    const nodeCryptoCreateHash = isNodeCryptoAvailable(nodeCrypto => {\n        if (typeof nodeCrypto.createHash === 'function') {\n            return nodeCrypto.createHash;\n        }\n        return false;\n    });\n    if (nodeCryptoCreateHash) {\n        return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n    }\n    else {\n        return new Ripemd160PolyfillDigest();\n    }\n}\nexport function hashRipemd160(data) {\n    const hash = createHashRipemd160();\n    return hash.digest(data);\n}\n//# sourceMappingURL=hashRipemd160.js.map"]},"metadata":{},"sourceType":"module"}