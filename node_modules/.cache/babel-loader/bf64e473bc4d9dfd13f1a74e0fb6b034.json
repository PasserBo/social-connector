{"ast":null,"code":"import _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport var TransactionSigner = /*#__PURE__*/function () {\n  function TransactionSigner(transaction) {\n    var _this = this;\n\n    _classCallCheck(this, TransactionSigner);\n\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n    var spendingCondition = transaction.auth.spendingCondition;\n\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (spendingCondition.fields.filter(function (field) {\n        return field.contents.type === StacksMessageType.MessageSignature;\n      }).length >= spendingCondition.signaturesRequired) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(function (field) {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          var signature = field.contents;\n          var nextVerify = nextVerification(_this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n          _this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  _createClass(TransactionSigner, [{\n    key: \"signOrigin\",\n    value: function signOrigin(privateKey) {\n      if (this.checkOverlap && this.originDone) {\n        throw new SigningError('Cannot sign origin after sponsor key');\n      }\n\n      if (this.transaction.auth === undefined) {\n        throw new SigningError('\"transaction.auth\" is undefined');\n      }\n\n      if (this.transaction.auth.spendingCondition === undefined) {\n        throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n      }\n\n      if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n        var spendingCondition = this.transaction.auth.spendingCondition;\n\n        if (this.checkOversign && spendingCondition.fields.filter(function (field) {\n          return field.contents.type === StacksMessageType.MessageSignature;\n        }).length >= spendingCondition.signaturesRequired) {\n          throw new Error('Origin would have too many signatures');\n        }\n      }\n\n      var nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n      this.sigHash = nextSighash;\n    }\n  }, {\n    key: \"appendOrigin\",\n    value: function appendOrigin(publicKey) {\n      if (this.checkOverlap && this.originDone) {\n        throw Error('Cannot append public key to origin after sponsor key');\n      }\n\n      if (this.transaction.auth === undefined) {\n        throw new Error('\"transaction.auth\" is undefined');\n      }\n\n      if (this.transaction.auth.spendingCondition === undefined) {\n        throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n      }\n\n      this.transaction.appendPubkey(publicKey);\n    }\n  }, {\n    key: \"signSponsor\",\n    value: function signSponsor(privateKey) {\n      if (this.transaction.auth === undefined) {\n        throw new SigningError('\"transaction.auth\" is undefined');\n      }\n\n      if (this.transaction.auth.authType !== AuthType.Sponsored) {\n        throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n      }\n\n      var nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n      this.sigHash = nextSighash;\n      this.originDone = true;\n    }\n  }, {\n    key: \"getTxInComplete\",\n    value: function getTxInComplete() {\n      return cloneDeep(this.transaction);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume(transaction) {\n      this.transaction = cloneDeep(transaction);\n      this.sigHash = transaction.signBegin();\n    }\n  }], [{\n    key: \"createSponsorSigner\",\n    value: function createSponsorSigner(transaction, spendingCondition) {\n      if (transaction.auth.authType != AuthType.Sponsored) {\n        throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n      }\n\n      var tx = cloneDeep(transaction);\n      tx.setSponsor(spendingCondition);\n      var originSigHash = tx.verifyOrigin();\n      var signer = new this(tx);\n      signer.originDone = true;\n      signer.sigHash = originSigHash;\n      signer.checkOversign = true;\n      signer.checkOverlap = true;\n      return signer;\n    }\n  }]);\n\n  return TransactionSigner;\n}();","map":{"version":3,"sources":["../../src/signer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport class TransactionSigner {\n    constructor(transaction) {\n        this.transaction = transaction;\n        this.sigHash = transaction.signBegin();\n        this.originDone = false;\n        this.checkOversign = true;\n        this.checkOverlap = true;\n        const spendingCondition = transaction.auth.spendingCondition;\n        if (spendingCondition && !isSingleSig(spendingCondition)) {\n            if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n                throw new Error('SpendingCondition has more signatures than are expected');\n            }\n            spendingCondition.fields.forEach(field => {\n                if (field.contents.type === StacksMessageType.MessageSignature) {\n                    const signature = field.contents;\n                    const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n                    this.sigHash = nextVerify.nextSigHash;\n                }\n            });\n        }\n    }\n    static createSponsorSigner(transaction, spendingCondition) {\n        if (transaction.auth.authType != AuthType.Sponsored) {\n            throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n        }\n        const tx = cloneDeep(transaction);\n        tx.setSponsor(spendingCondition);\n        const originSigHash = tx.verifyOrigin();\n        const signer = new this(tx);\n        signer.originDone = true;\n        signer.sigHash = originSigHash;\n        signer.checkOversign = true;\n        signer.checkOverlap = true;\n        return signer;\n    }\n    signOrigin(privateKey) {\n        if (this.checkOverlap && this.originDone) {\n            throw new SigningError('Cannot sign origin after sponsor key');\n        }\n        if (this.transaction.auth === undefined) {\n            throw new SigningError('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.spendingCondition === undefined) {\n            throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n        }\n        if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n            const spendingCondition = this.transaction.auth.spendingCondition;\n            if (this.checkOversign &&\n                spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n                throw new Error('Origin would have too many signatures');\n            }\n        }\n        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n        this.sigHash = nextSighash;\n    }\n    appendOrigin(publicKey) {\n        if (this.checkOverlap && this.originDone) {\n            throw Error('Cannot append public key to origin after sponsor key');\n        }\n        if (this.transaction.auth === undefined) {\n            throw new Error('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.spendingCondition === undefined) {\n            throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n        }\n        this.transaction.appendPubkey(publicKey);\n    }\n    signSponsor(privateKey) {\n        if (this.transaction.auth === undefined) {\n            throw new SigningError('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.authType !== AuthType.Sponsored) {\n            throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n        }\n        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n        this.sigHash = nextSighash;\n        this.originDone = true;\n    }\n    getTxInComplete() {\n        return cloneDeep(this.transaction);\n    }\n    resume(transaction) {\n        this.transaction = cloneDeep(transaction);\n        this.sigHash = transaction.signBegin();\n    }\n}\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"module"}