{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar baddress = require('./address');\n\nvar bufferutils_1 = require('./bufferutils');\n\nvar classify = require('./classify');\n\nvar bcrypto = require('./crypto');\n\nvar ECPair = require('./ecpair');\n\nvar networks = require('./networks');\n\nvar payments = require('./payments');\n\nvar bscript = require('./script');\n\nvar script_1 = require('./script');\n\nvar transaction_1 = require('./transaction');\n\nvar types = require('./types');\n\nvar typeforce = require('typeforce');\n\nvar SCRIPT_TYPES = classify.types;\nvar PREVOUT_TYPES = new Set([// Raw\n'p2pkh', 'p2pk', 'p2wpkh', 'p2ms', // P2SH wrapped\n'p2sh-p2pkh', 'p2sh-p2pk', 'p2sh-p2wpkh', 'p2sh-p2ms', // P2WSH wrapped\n'p2wsh-p2pkh', 'p2wsh-p2pk', 'p2wsh-p2ms', // P2SH-P2WSH wrapper\n'p2sh-p2wsh-p2pkh', 'p2sh-p2wsh-p2pk', 'p2sh-p2wsh-p2ms']);\n\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\n\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\n\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\n\nvar TransactionBuilder = /*#__PURE__*/function () {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  function TransactionBuilder() {\n    var network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : networks.bitcoin;\n    var maximumFeeRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2500;\n\n    _classCallCheck(this, TransactionBuilder);\n\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn('Deprecation Warning: TransactionBuilder will be removed in the future. ' + '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' + 'are available in the transactions-psbt.js integration test file on our ' + 'Github. A high level explanation is available in the psbt.ts and psbt.js ' + 'files as well.');\n  }\n\n  _createClass(TransactionBuilder, [{\n    key: \"setLowR\",\n    value: function setLowR(setting) {\n      typeforce(typeforce.maybe(typeforce.Boolean), setting);\n\n      if (setting === undefined) {\n        setting = true;\n      }\n\n      this.__USE_LOW_R = setting;\n      return setting;\n    }\n  }, {\n    key: \"setLockTime\",\n    value: function setLockTime(locktime) {\n      typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n      if (this.__INPUTS.some(function (input) {\n        if (!input.signatures) return false;\n        return input.signatures.some(function (s) {\n          return s !== undefined;\n        });\n      })) {\n        throw new Error('No, this would invalidate signatures');\n      }\n\n      this.__TX.locktime = locktime;\n    }\n  }, {\n    key: \"setVersion\",\n    value: function setVersion(version) {\n      typeforce(types.UInt32, version); // XXX: this might eventually become more complex depending on what the versions represent\n\n      this.__TX.version = version;\n    }\n  }, {\n    key: \"addInput\",\n    value: function addInput(txHash, vout, sequence, prevOutScript) {\n      if (!this.__canModifyInputs()) {\n        throw new Error('No, this would invalidate signatures');\n      }\n\n      var value; // is it a hex string?\n\n      if (txIsString(txHash)) {\n        // transaction hashs's are displayed in reverse order, un-reverse it\n        txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex')); // is it a Transaction object?\n      } else if (txIsTransaction(txHash)) {\n        var txOut = txHash.outs[vout];\n        prevOutScript = txOut.script;\n        value = txOut.value;\n        txHash = txHash.getHash(false);\n      }\n\n      return this.__addInputUnsafe(txHash, vout, {\n        sequence: sequence,\n        prevOutScript: prevOutScript,\n        value: value\n      });\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(scriptPubKey, value) {\n      if (!this.__canModifyOutputs()) {\n        throw new Error('No, this would invalidate signatures');\n      } // Attempt to get a script if it's a base58 or bech32 address string\n\n\n      if (typeof scriptPubKey === 'string') {\n        scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n      }\n\n      return this.__TX.addOutput(scriptPubKey, value);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return this.__build(false);\n    }\n  }, {\n    key: \"buildIncomplete\",\n    value: function buildIncomplete() {\n      return this.__build(true);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n      trySign(getSigningData(this.network, this.__INPUTS, this.__needsOutputs.bind(this), this.__TX, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, this.__USE_LOW_R));\n    }\n  }, {\n    key: \"__addInputUnsafe\",\n    value: function __addInputUnsafe(txHash, vout, options) {\n      if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n        throw new Error('coinbase inputs not supported');\n      }\n\n      var prevTxOut = txHash.toString('hex') + ':' + vout;\n      if (this.__PREV_TX_SET[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n      var input = {}; // derive what we can from the scriptSig\n\n      if (options.script !== undefined) {\n        input = expandInput(options.script, options.witness || []);\n      } // if an input value was given, retain it\n\n\n      if (options.value !== undefined) {\n        input.value = options.value;\n      } // derive what we can from the previous transactions output script\n\n\n      if (!input.prevOutScript && options.prevOutScript) {\n        var prevOutType;\n\n        if (!input.pubkeys && !input.signatures) {\n          var expanded = expandOutput(options.prevOutScript);\n\n          if (expanded.pubkeys) {\n            input.pubkeys = expanded.pubkeys;\n            input.signatures = expanded.signatures;\n          }\n\n          prevOutType = expanded.type;\n        }\n\n        input.prevOutScript = options.prevOutScript;\n        input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n      }\n\n      var vin = this.__TX.addInput(txHash, vout, options.sequence, options.scriptSig);\n\n      this.__INPUTS[vin] = input;\n      this.__PREV_TX_SET[prevTxOut] = true;\n      return vin;\n    }\n  }, {\n    key: \"__build\",\n    value: function __build(allowIncomplete) {\n      if (!allowIncomplete) {\n        if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n        if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n      }\n\n      var tx = this.__TX.clone(); // create script signatures from inputs\n\n\n      this.__INPUTS.forEach(function (input, i) {\n        if (!input.prevOutType && !allowIncomplete) throw new Error('Transaction is not complete');\n        var result = build(input.prevOutType, input, allowIncomplete);\n\n        if (!result) {\n          if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD) throw new Error('Unknown input type');\n          if (!allowIncomplete) throw new Error('Not enough information');\n          return;\n        }\n\n        tx.setInputScript(i, result.input);\n        tx.setWitness(i, result.witness);\n      });\n\n      if (!allowIncomplete) {\n        // do not rely on this, its merely a last resort\n        if (this.__overMaximumFees(tx.virtualSize())) {\n          throw new Error('Transaction has absurd fees');\n        }\n      }\n\n      return tx;\n    }\n  }, {\n    key: \"__canModifyInputs\",\n    value: function __canModifyInputs() {\n      return this.__INPUTS.every(function (input) {\n        if (!input.signatures) return true;\n        return input.signatures.every(function (signature) {\n          if (!signature) return true;\n          var hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n          // be invalidated by more inputs\n\n          return (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0;\n        });\n      });\n    }\n  }, {\n    key: \"__needsOutputs\",\n    value: function __needsOutputs(signingHashType) {\n      if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n        return this.__TX.outs.length === 0;\n      } // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n      // .build() will fail, but .buildIncomplete() is OK\n\n\n      return this.__TX.outs.length === 0 && this.__INPUTS.some(function (input) {\n        if (!input.signatures) return false;\n        return input.signatures.some(function (signature) {\n          if (!signature) return false; // no signature, no issue\n\n          var hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n\n          return true; // SIGHASH_* does care\n        });\n      });\n    }\n  }, {\n    key: \"__canModifyOutputs\",\n    value: function __canModifyOutputs() {\n      var nInputs = this.__TX.ins.length;\n      var nOutputs = this.__TX.outs.length;\n      return this.__INPUTS.every(function (input) {\n        if (input.signatures === undefined) return true;\n        return input.signatures.every(function (signature) {\n          if (!signature) return true;\n          var hashType = signatureHashType(signature);\n          var hashTypeMod = hashType & 0x1f;\n          if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n\n          if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n            // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n            // some signatures would be invalidated by the addition\n            // of more outputs\n            return nInputs <= nOutputs;\n          }\n\n          return false;\n        });\n      });\n    }\n  }, {\n    key: \"__overMaximumFees\",\n    value: function __overMaximumFees(bytes) {\n      // not all inputs will have .value defined\n      var incoming = this.__INPUTS.reduce(function (a, x) {\n        return a + (x.value >>> 0);\n      }, 0); // but all outputs do, and if we have any input value\n      // we can immediately determine if the outputs are too small\n\n\n      var outgoing = this.__TX.outs.reduce(function (a, x) {\n        return a + x.value;\n      }, 0);\n\n      var fee = incoming - outgoing;\n      var feeRate = fee / bytes;\n      return feeRate > this.maximumFeeRate;\n    }\n  }], [{\n    key: \"fromTransaction\",\n    value: function fromTransaction(transaction, network) {\n      var txb = new TransactionBuilder(network); // Copy transaction fields\n\n      txb.setVersion(transaction.version);\n      txb.setLockTime(transaction.locktime); // Copy outputs (done first to avoid signature invalidation)\n\n      transaction.outs.forEach(function (txOut) {\n        txb.addOutput(txOut.script, txOut.value);\n      }); // Copy inputs\n\n      transaction.ins.forEach(function (txIn) {\n        txb.__addInputUnsafe(txIn.hash, txIn.index, {\n          sequence: txIn.sequence,\n          script: txIn.script,\n          witness: txIn.witness\n        });\n      }); // fix some things not possible through the public API\n\n      txb.__INPUTS.forEach(function (input, i) {\n        fixMultisigOrder(input, transaction, i);\n      });\n\n      return txb;\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n\nexports.TransactionBuilder = TransactionBuilder;\n\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n\n  if (!type) {\n    var ssType = classify.input(scriptSig, true);\n    var wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        var _payments$p2wpkh = payments.p2wpkh({\n          witness: witnessStack\n        }),\n            output = _payments$p2wpkh.output,\n            pubkey = _payments$p2wpkh.pubkey,\n            signature = _payments$p2wpkh.signature;\n\n        return {\n          prevOutScript: output,\n          prevOutType: SCRIPT_TYPES.P2WPKH,\n          pubkeys: [pubkey],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PKH:\n      {\n        var _payments$p2pkh = payments.p2pkh({\n          input: scriptSig\n        }),\n            _output = _payments$p2pkh.output,\n            _pubkey = _payments$p2pkh.pubkey,\n            _signature = _payments$p2pkh.signature;\n\n        return {\n          prevOutScript: _output,\n          prevOutType: SCRIPT_TYPES.P2PKH,\n          pubkeys: [_pubkey],\n          signatures: [_signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        var _payments$p2pk = payments.p2pk({\n          input: scriptSig\n        }),\n            _signature2 = _payments$p2pk.signature;\n\n        return {\n          prevOutType: SCRIPT_TYPES.P2PK,\n          pubkeys: [undefined],\n          signatures: [_signature2]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        var _payments$p2ms = payments.p2ms({\n          input: scriptSig,\n          output: scriptPubKey\n        }, {\n          allowIncomplete: true\n        }),\n            m = _payments$p2ms.m,\n            pubkeys = _payments$p2ms.pubkeys,\n            signatures = _payments$p2ms.signatures;\n\n        return {\n          prevOutType: SCRIPT_TYPES.P2MS,\n          pubkeys: pubkeys,\n          signatures: signatures,\n          maxSignatures: m\n        };\n      }\n  }\n\n  if (type === SCRIPT_TYPES.P2SH) {\n    var _payments$p2sh = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack\n    }),\n        _output2 = _payments$p2sh.output,\n        redeem = _payments$p2sh.redeem;\n\n    var outputType = classify.output(redeem.output);\n    var expanded = expandInput(redeem.input, redeem.witness, outputType, redeem.output);\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: _output2,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    };\n  }\n\n  if (type === SCRIPT_TYPES.P2WSH) {\n    var _payments$p2wsh = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack\n    }),\n        _output3 = _payments$p2wsh.output,\n        _redeem = _payments$p2wsh.redeem;\n\n    var _outputType = classify.output(_redeem.output);\n\n    var _expanded;\n\n    if (_outputType === SCRIPT_TYPES.P2WPKH) {\n      _expanded = expandInput(_redeem.input, _redeem.witness, _outputType);\n    } else {\n      _expanded = expandInput(bscript.compile(_redeem.witness), [], _outputType, _redeem.output);\n    }\n\n    if (!_expanded.prevOutType) return {};\n    return {\n      prevOutScript: _output3,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: _redeem.output,\n      witnessScriptType: _expanded.prevOutType,\n      pubkeys: _expanded.pubkeys,\n      signatures: _expanded.signatures\n    };\n  }\n\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig\n  };\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript) return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKey(pubKey);\n    var match; // check for a signature\n\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      var parsed = bscript.signature.decode(signature);\n      var hash = transaction.hashForSignature(vin, input.redeemScript, parsed.hashType); // skip if signature does not match pubKey\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var type = classify.output(script);\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (!ourPubKey) return {\n          type: type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        var pkh1 = payments.p2pkh({\n          output: script\n        }).hash;\n        var pkh2 = bcrypto.hash160(ourPubKey);\n        if (!pkh1.equals(pkh2)) return {\n          type: type\n        };\n        return {\n          type: type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (!ourPubKey) return {\n          type: type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        var wpkh1 = payments.p2wpkh({\n          output: script\n        }).hash;\n        var wpkh2 = bcrypto.hash160(ourPubKey);\n        if (!wpkh1.equals(wpkh2)) return {\n          type: type\n        };\n        return {\n          type: type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        var p2pk = payments.p2pk({\n          output: script\n        });\n        return {\n          type: type,\n          pubkeys: [p2pk.pubkey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        var p2ms = payments.p2ms({\n          output: script\n        });\n        return {\n          type: type,\n          pubkeys: p2ms.pubkeys,\n          signatures: p2ms.pubkeys.map(function () {\n            return undefined;\n          }),\n          maxSignatures: p2ms.m\n        };\n      }\n  }\n\n  return {\n    type: type\n  };\n}\n\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    var p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n    var p2wshAlt = payments.p2wsh({\n      output: redeemScript\n    });\n    var p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n    var p2shAlt = payments.p2sh({\n      redeem: p2wsh\n    }); // enforces P2SH(P2WSH(...))\n\n    if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    var expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(function (x) {\n      return x !== undefined;\n    })) {\n      expanded.signatures = input.signatures;\n    }\n\n    var signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript: redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript: witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript: signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (redeemScript) {\n    var _p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      var _p2shAlt;\n\n      try {\n        _p2shAlt = payments.p2sh({\n          output: input.prevOutScript\n        });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n\n      if (!_p2sh.hash.equals(_p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n\n    var _expanded2 = expandOutput(_p2sh.redeem.output, ourPubKey);\n\n    if (!_expanded2.pubkeys) throw new Error(_expanded2.type + ' not supported as redeemScript (' + bscript.toASM(redeemScript) + ')');\n\n    if (input.signatures && input.signatures.some(function (x) {\n      return x !== undefined;\n    })) {\n      _expanded2.signatures = input.signatures;\n    }\n\n    var _signScript = redeemScript;\n\n    if (_expanded2.type === SCRIPT_TYPES.P2WPKH) {\n      _signScript = payments.p2pkh({\n        pubkey: _expanded2.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      redeemScript: redeemScript,\n      redeemScriptType: _expanded2.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: _p2sh.output,\n      hasWitness: _expanded2.type === SCRIPT_TYPES.P2WPKH,\n      signScript: _signScript,\n      signType: _expanded2.type,\n      pubkeys: _expanded2.pubkeys,\n      signatures: _expanded2.signatures,\n      maxSignatures: _expanded2.maxSignatures\n    };\n  }\n\n  if (witnessScript) {\n    var _p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      var _p2wshAlt = payments.p2wsh({\n        output: input.prevOutScript\n      });\n\n      if (!_p2wsh.hash.equals(_p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    }\n\n    var _expanded3 = expandOutput(_p2wsh.redeem.output, ourPubKey);\n\n    if (!_expanded3.pubkeys) throw new Error(_expanded3.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(function (x) {\n      return x !== undefined;\n    })) {\n      _expanded3.signatures = input.signatures;\n    }\n\n    var _signScript2 = witnessScript;\n    if (_expanded3.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript: witnessScript,\n      witnessScriptType: _expanded3.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: _p2wsh.output,\n      hasWitness: true,\n      signScript: _signScript2,\n      signType: _expanded3.type,\n      pubkeys: _expanded3.pubkeys,\n      signatures: _expanded3.signatures,\n      maxSignatures: _expanded3.maxSignatures\n    };\n  }\n\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires witnessScript');\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n\n    var _expanded4 = expandOutput(input.prevOutScript, ourPubKey);\n\n    if (!_expanded4.pubkeys) throw new Error(_expanded4.type + ' not supported (' + bscript.toASM(input.prevOutScript) + ')');\n\n    if (input.signatures && input.signatures.some(function (x) {\n      return x !== undefined;\n    })) {\n      _expanded4.signatures = input.signatures;\n    }\n\n    var _signScript3 = input.prevOutScript;\n\n    if (_expanded4.type === SCRIPT_TYPES.P2WPKH) {\n      _signScript3 = payments.p2pkh({\n        pubkey: _expanded4.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      prevOutType: _expanded4.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: _expanded4.type === SCRIPT_TYPES.P2WPKH,\n      signScript: _signScript3,\n      signType: _expanded4.type,\n      pubkeys: _expanded4.pubkeys,\n      signatures: _expanded4.signatures,\n      maxSignatures: _expanded4.maxSignatures\n    };\n  }\n\n  var prevOutScript = payments.p2pkh({\n    pubkey: ourPubKey\n  }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript: prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined]\n  };\n}\n\nfunction build(type, input, allowIncomplete) {\n  var pubkeys = input.pubkeys || [];\n  var signatures = input.signatures || [];\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2wpkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pk({\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        var m = input.maxSignatures;\n\n        if (allowIncomplete) {\n          signatures = signatures.map(function (x) {\n            return x || script_1.OPS.OP_0;\n          });\n        } else {\n          signatures = signatures.filter(function (x) {\n            return x;\n          });\n        } // if the transaction is not not complete (complete), or if signatures.length === m, validate\n        // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n\n\n        var validate = !allowIncomplete || m === signatures.length;\n        return payments.p2ms({\n          m: m,\n          pubkeys: pubkeys,\n          signatures: signatures\n        }, {\n          allowIncomplete: allowIncomplete,\n          validate: validate\n        });\n      }\n\n    case SCRIPT_TYPES.P2SH:\n      {\n        var redeem = build(input.redeemScriptType, input, allowIncomplete);\n        if (!redeem) return;\n        return payments.p2sh({\n          redeem: {\n            output: redeem.output || input.redeemScript,\n            input: redeem.input,\n            witness: redeem.witness\n          }\n        });\n      }\n\n    case SCRIPT_TYPES.P2WSH:\n      {\n        var _redeem2 = build(input.witnessScriptType, input, allowIncomplete);\n\n        if (!_redeem2) return;\n        return payments.p2wsh({\n          redeem: {\n            output: input.witnessScript,\n            input: _redeem2.input,\n            witness: _redeem2.witness\n          }\n        });\n      }\n  }\n}\n\nfunction canSign(input) {\n  return input.signScript !== undefined && input.signType !== undefined && input.pubkeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubkeys.length && input.pubkeys.length > 0 && (input.hasWitness === false || input.value !== undefined);\n}\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\"Unknown prevOutScriptType \\\"\".concat(signParams.prevOutScriptType, \"\\\"\"));\n  }\n\n  tfMessage(typeforce.Number, signParams.vin, \"sign must include vin parameter as Number (input index)\");\n  tfMessage(types.Signer, signParams.keyPair, \"sign must include keyPair parameter as Signer interface\");\n  tfMessage(typeforce.maybe(typeforce.Number), signParams.hashType, \"sign hashType parameter must be a number\");\n  var prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  var posType = signParams.prevOutScriptType;\n\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2pkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2pk: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2wpkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2ms: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2sh-p2wpkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessScript\"));\n      break;\n  }\n}\n\nfunction trySign(_ref) {\n  var input = _ref.input,\n      ourPubKey = _ref.ourPubKey,\n      keyPair = _ref.keyPair,\n      signatureHash = _ref.signatureHash,\n      hashType = _ref.hashType,\n      useLowR = _ref.useLowR;\n  // enforce in order signing of public keys\n  var signed = false;\n\n  var _iterator = _createForOfIteratorHelper(input.pubkeys.entries()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          i = _step$value[0],\n          pubKey = _step$value[1];\n\n      if (!ourPubKey.equals(pubKey)) continue;\n      if (input.signatures[i]) throw new Error('Signature already exists'); // TODO: add tests\n\n      if (ourPubKey.length !== 33 && input.hasWitness) {\n        throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n      }\n\n      var signature = keyPair.sign(signatureHash, useLowR);\n      input.signatures[i] = bscript.signature.encode(signature, hashType);\n      signed = true;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\n\nfunction getSigningData(network, inputs, needsOutputs, tx, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, useLowR) {\n  var vin;\n\n  if (typeof signParams === 'number') {\n    console.warn('DEPRECATED: TransactionBuilder sign method arguments ' + 'will change in v6, please use the TxbSignArg interface');\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    vin = signParams.vin;\n    keyPair = signParams.keyPair;\n    redeemScript = signParams.redeemScript;\n    hashType = signParams.hashType;\n    witnessValue = signParams.witnessValue;\n    witnessScript = signParams.witnessScript;\n  } else {\n    throw new TypeError('TransactionBuilder sign first arg must be TxbSignArg or number');\n  }\n\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  } // TODO: remove keyPair.network matching in 4.0.0\n\n\n  if (keyPair.network && keyPair.network !== network) throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  var input = inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  var ourPubKey = keyPair.publicKey || keyPair.getPublicKey && keyPair.getPublicKey();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    if (!canSign(input)) {\n      var prepared = prepareInput(input, ourPubKey, redeemScript, witnessScript); // updates inline\n\n      Object.assign(input, prepared);\n    }\n\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n\n\n  var signatureHash;\n\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(vin, input.signScript, input.value, hashType);\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n\n  return {\n    input: input,\n    ourPubKey: ourPubKey,\n    keyPair: keyPair,\n    signatureHash: signatureHash,\n    hashType: hashType,\n    useLowR: !!useLowR\n  };\n}","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bitcoinjs-lib/src/transaction_builder.js"],"names":["Object","defineProperty","exports","value","baddress","require","bufferutils_1","classify","bcrypto","ECPair","networks","payments","bscript","script_1","transaction_1","types","typeforce","SCRIPT_TYPES","PREVOUT_TYPES","Set","tfMessage","type","message","err","Error","txIsString","tx","String","txIsTransaction","Transaction","TransactionBuilder","network","bitcoin","maximumFeeRate","__PREV_TX_SET","__INPUTS","__TX","version","__USE_LOW_R","console","warn","setting","maybe","Boolean","undefined","locktime","UInt32","some","input","signatures","s","txHash","vout","sequence","prevOutScript","__canModifyInputs","reverseBuffer","Buffer","from","txOut","outs","script","getHash","__addInputUnsafe","scriptPubKey","__canModifyOutputs","toOutputScript","addOutput","__build","signParams","keyPair","redeemScript","hashType","witnessValue","witnessScript","trySign","getSigningData","__needsOutputs","bind","options","isCoinbaseHash","prevTxOut","toString","expandInput","witness","prevOutType","pubkeys","expanded","expandOutput","output","vin","addInput","scriptSig","allowIncomplete","ins","length","clone","forEach","i","result","build","NONSTANDARD","setInputScript","setWitness","__overMaximumFees","virtualSize","every","signature","signatureHashType","SIGHASH_ANYONECANPAY","signingHashType","SIGHASH_ALL","SIGHASH_NONE","nInputs","nOutputs","hashTypeMod","SIGHASH_SINGLE","bytes","incoming","reduce","a","x","outgoing","fee","feeRate","transaction","txb","setVersion","setLockTime","txIn","hash","index","fixMultisigOrder","witnessStack","ssType","wsType","P2WPKH","p2wpkh","pubkey","P2PKH","p2pkh","P2PK","p2pk","P2MS","p2ms","m","maxSignatures","P2SH","p2sh","redeem","outputType","redeemScriptType","witnessScriptType","P2WSH","p2wsh","compile","unmatched","concat","map","pubKey","fromPublicKey","match","parsed","decode","hashForSignature","verify","ourPubKey","pkh1","pkh2","hash160","equals","wpkh1","wpkh2","prepareInput","p2wshAlt","p2shAlt","toASM","signScript","hasWitness","signType","e","OPS","OP_0","filter","validate","canSign","buffer","readUInt8","checkSignArgs","inputs","has","prevOutScriptType","TypeError","Number","Signer","posType","Satoshi","signatureHash","useLowR","signed","entries","sign","encode","needsOutputs","publicKey","getPublicKey","prepared","assign","hashForWitnessV0"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network);\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n    return txb;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(\n        vin,\n        input.redeemScript,\n        parsed.hashType,\n      );\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}