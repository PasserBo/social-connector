{"ast":null,"code":"import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength\n  };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName)\n  };\n}\nexport function createAddress(c32AddressString) {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1]\n  };\n}\nexport function parsePrincipalString(principalString) {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\nexport function createContractPrincipal(addressString, contractName) {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name\n  };\n}\nexport function createStandardPrincipal(addressString) {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr\n  };\n}","map":{"version":3,"sources":["../../src/postcondition-types.ts"],"names":[],"mappings":"AAAA,SAEE,uBAFF,EAIE,wBAJF,EAME,iBANF,QAOO,aAPP;AAQA,SAAS,gBAAT,QAAiC,UAAjC;AAGA,SAAS,qBAAT,QAAsC,SAAtC;AAyDA,OAAM,SAAU,oBAAV,CAA+B,EAA/B,EAAyC;AAC7C,QAAM,CAAC,YAAD,EAAe,iBAAf,EAAkC,cAAlC,IAAoD,EAAE,CAAC,KAAH,CAAS,OAAT,CAA1D;AACA,QAAM,SAAS,GAAG,eAAe,CAAC,YAAD,EAAe,iBAAf,EAAkC,cAAlC,CAAjC;AACA,SAAO,SAAP;AACD;AASD,OAAM,SAAU,cAAV,CACJ,OADI,EAEJ,iBAFI,EAGJ,cAHI,EAGmB;AAEvB,QAAM,YAAY,GAAG,iBAAiB,IAAI,CAA1C;AACA,QAAM,SAAS,GAAG,cAAc,IAAI,uBAApC;;AACA,MAAI,qBAAqB,CAAC,OAAD,EAAU,SAAV,CAAzB,EAA+C;AAC7C,UAAM,IAAI,KAAJ,CAAU,uCAAuC,SAAS,CAAC,QAAV,EAAoB,EAArE,CAAN;AACD;;AACD,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,oBADnB;AAEL,IAAA,OAFK;AAGL,IAAA,iBAAiB,EAAE,YAHd;AAIL,IAAA,cAAc,EAAE;AAJX,GAAP;AAMD;AAED,OAAM,SAAU,eAAV,CACJ,aADI,EAEJ,YAFI,EAGJ,SAHI,EAGa;AAEjB,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,SADnB;AAEL,IAAA,OAAO,EAAE,aAAa,CAAC,aAAD,CAFjB;AAGL,IAAA,YAAY,EAAE,cAAc,CAAC,YAAD,CAHvB;AAIL,IAAA,SAAS,EAAE,cAAc,CAAC,SAAD;AAJpB,GAAP;AAMD;AAED,OAAM,SAAU,aAAV,CAAwB,gBAAxB,EAAgD;AACpD,QAAM,WAAW,GAAG,gBAAgB,CAAC,gBAAD,CAApC;AACA,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,OADnB;AAEL,IAAA,OAAO,EAAE,WAAW,CAAC,CAAD,CAFf;AAGL,IAAA,OAAO,EAAE,WAAW,CAAC,CAAD;AAHf,GAAP;AAKD;AAQD,OAAM,SAAU,oBAAV,CACJ,eADI,EACmB;AAEvB,MAAI,eAAe,CAAC,QAAhB,CAAyB,GAAzB,CAAJ,EAAmC;AACjC,UAAM,CAAC,OAAD,EAAU,YAAV,IAA0B,eAAe,CAAC,KAAhB,CAAsB,GAAtB,CAAhC;AACA,WAAO,uBAAuB,CAAC,OAAD,EAAU,YAAV,CAA9B;AACD,GAHD,MAGO;AACL,WAAO,uBAAuB,CAAC,eAAD,CAA9B;AACD;AACF;AAED,OAAM,SAAU,uBAAV,CACJ,aADI,EAEJ,YAFI,EAEgB;AAEpB,QAAM,IAAI,GAAG,aAAa,CAAC,aAAD,CAA1B;AACA,QAAM,IAAI,GAAG,cAAc,CAAC,YAAD,CAA3B;AACA,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,SADnB;AAEL,IAAA,MAAM,EAAE,wBAAwB,CAAC,QAF5B;AAGL,IAAA,OAAO,EAAE,IAHJ;AAIL,IAAA,YAAY,EAAE;AAJT,GAAP;AAMD;AAED,OAAM,SAAU,uBAAV,CAAkC,aAAlC,EAAuD;AAC3D,QAAM,IAAI,GAAG,aAAa,CAAC,aAAD,CAA1B;AACA,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,SADnB;AAEL,IAAA,MAAM,EAAE,wBAAwB,CAAC,QAF5B;AAGL,IAAA,OAAO,EAAE;AAHJ,GAAP;AAKD","sourceRoot":"","sourcesContent":["import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType, } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n    const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n    return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n    const prefixLength = lengthPrefixBytes || 1;\n    const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n    if (exceedsMaxLengthBytes(content, maxLength)) {\n        throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n    }\n    return {\n        type: StacksMessageType.LengthPrefixedString,\n        content,\n        lengthPrefixBytes: prefixLength,\n        maxLengthBytes: maxLength,\n    };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n    return {\n        type: StacksMessageType.AssetInfo,\n        address: createAddress(addressString),\n        contractName: createLPString(contractName),\n        assetName: createLPString(assetName),\n    };\n}\nexport function createAddress(c32AddressString) {\n    const addressData = c32addressDecode(c32AddressString);\n    return {\n        type: StacksMessageType.Address,\n        version: addressData[0],\n        hash160: addressData[1],\n    };\n}\nexport function parsePrincipalString(principalString) {\n    if (principalString.includes('.')) {\n        const [address, contractName] = principalString.split('.');\n        return createContractPrincipal(address, contractName);\n    }\n    else {\n        return createStandardPrincipal(principalString);\n    }\n}\nexport function createContractPrincipal(addressString, contractName) {\n    const addr = createAddress(addressString);\n    const name = createLPString(contractName);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Contract,\n        address: addr,\n        contractName: name,\n    };\n}\nexport function createStandardPrincipal(addressString) {\n    const addr = createAddress(addressString);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Standard,\n        address: addr,\n    };\n}\n//# sourceMappingURL=postcondition-types.js.map"]},"metadata":{},"sourceType":"module"}