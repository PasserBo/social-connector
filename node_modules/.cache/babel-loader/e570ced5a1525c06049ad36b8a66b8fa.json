{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer } from '@stacks/common';\nimport { ec as EllipticCurve } from 'elliptic';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nvar ecurve = new EllipticCurve('secp256k1');\nexport var InvalidPublicKeyReason;\n\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\n\nexport function aes256CbcEncrypt(_x, _x2, _x3) {\n  return _aes256CbcEncrypt.apply(this, arguments);\n}\n\nfunction _aes256CbcEncrypt() {\n  _aes256CbcEncrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(iv, key, plaintext) {\n    var cipher, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return createCipher();\n\n          case 2:\n            cipher = _context.sent;\n            _context.next = 5;\n            return cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n\n          case 5:\n            result = _context.sent;\n            return _context.abrupt(\"return\", result);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _aes256CbcEncrypt.apply(this, arguments);\n}\n\nfunction aes256CbcDecrypt(_x4, _x5, _x6) {\n  return _aes256CbcDecrypt.apply(this, arguments);\n}\n\nfunction _aes256CbcDecrypt() {\n  _aes256CbcDecrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(iv, key, ciphertext) {\n    var cipher, result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return createCipher();\n\n          case 2:\n            cipher = _context2.sent;\n            _context2.next = 5;\n            return cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n\n          case 5:\n            result = _context2.sent;\n            return _context2.abrupt(\"return\", result);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _aes256CbcDecrypt.apply(this, arguments);\n}\n\nfunction hmacSha256(_x7, _x8) {\n  return _hmacSha.apply(this, arguments);\n}\n\nfunction _hmacSha() {\n  _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, content) {\n    var hmacSha256;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return createHmacSha256();\n\n          case 2:\n            hmacSha256 = _context3.sent;\n            return _context3.abrupt(\"return\", hmacSha256.digest(key, content));\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _hmacSha.apply(this, arguments);\n}\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  var res = 0;\n\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];\n  }\n\n  return res === 0;\n}\n\nfunction sharedSecretToKeys(sharedSecret) {\n  var hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\nfunction isValidPublicKey(pub) {\n  var invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  var invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  var firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n  var secp256k1 = new EllipticCurve('secp256k1');\n\n  try {\n    var keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));\n    var result = keyPair.validate();\n    return {\n      result: result.result,\n      reason_data: result.reason,\n      reason: result.result ? null : InvalidPublicKeyReason.IsNotPoint\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\nexport function getHexFromBN(bnInput) {\n  var hexOut = bnInput.toString('hex', 64);\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    var padding = '0'.repeat(64 - hexOut.length);\n    return \"\".concat(padding).concat(hexOut);\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBufferFromBN(bnInput) {\n  var result = bnInput.toArrayLike(Buffer, 'be', 32);\n\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte BN');\n  }\n\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  var shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n\n  var ivLength = 32;\n  var ephemeralPKLength = 66;\n  var macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  var shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  var signatureLength = 144;\n  var publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  var _getCipherObjectWrapp = getCipherObjectWrapper(opts),\n      payloadShell = _getCipherObjectWrapp.payloadShell,\n      payloadValuesLength = _getCipherObjectWrapp.payloadValuesLength;\n\n  var cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  var encodedCipherTextLength;\n\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(opts.cipherTextEncoding, \"\\\"\"));\n  }\n\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    var _getSignedCipherObjec = getSignedCipherObjectWrapper(payloadShell),\n        signedPayloadShell = _getSignedCipherObjec.signedPayloadShell,\n        signedPayloadValuesLength = _getSignedCipherObjec.signedPayloadValuesLength;\n\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport function encryptECIES(_x9, _x10, _x11, _x12) {\n  return _encryptECIES.apply(this, arguments);\n}\n\nfunction _encryptECIES() {\n  _encryptECIES = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(publicKey, content, wasString, cipherTextEncoding) {\n    var validity, ecPK, ephemeralSK, ephemeralPK, sharedSecret, sharedSecretBuffer, sharedKeys, initializationVector, cipherText, macData, mac, cipherTextString, result;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            validity = isValidPublicKey(publicKey);\n\n            if (validity.result) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw validity;\n\n          case 3:\n            ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n            ephemeralSK = ecurve.genKeyPair();\n            ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n            sharedSecret = ephemeralSK.derive(ecPK);\n            sharedSecretBuffer = getBufferFromBN(sharedSecret);\n            sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n            initializationVector = randomBytes(16);\n            _context4.next = 12;\n            return aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n\n          case 12:\n            cipherText = _context4.sent;\n            macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n            _context4.next = 16;\n            return hmacSha256(sharedKeys.hmacKey, macData);\n\n          case 16:\n            mac = _context4.sent;\n\n            if (!(!cipherTextEncoding || cipherTextEncoding === 'hex')) {\n              _context4.next = 21;\n              break;\n            }\n\n            cipherTextString = cipherText.toString('hex');\n            _context4.next = 26;\n            break;\n\n          case 21:\n            if (!(cipherTextEncoding === 'base64')) {\n              _context4.next = 25;\n              break;\n            }\n\n            cipherTextString = cipherText.toString('base64');\n            _context4.next = 26;\n            break;\n\n          case 25:\n            throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(cipherTextEncoding, \"\\\"\"));\n\n          case 26:\n            result = {\n              iv: initializationVector.toString('hex'),\n              ephemeralPK: ephemeralPK.toString('hex'),\n              cipherText: cipherTextString,\n              mac: mac.toString('hex'),\n              wasString: !!wasString\n            };\n\n            if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n              result.cipherTextEncoding = cipherTextEncoding;\n            }\n\n            return _context4.abrupt(\"return\", result);\n\n          case 29:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _encryptECIES.apply(this, arguments);\n}\n\nexport function decryptECIES(_x13, _x14) {\n  return _decryptECIES.apply(this, arguments);\n}\n\nfunction _decryptECIES() {\n  _decryptECIES = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(privateKey, cipherObject) {\n    var ecSK, ephemeralPK, sharedSecret, sharedSecretBuffer, sharedKeys, ivBuffer, cipherTextBuffer, macData, actualMac, expectedMac, plainText;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n            ephemeralPK = null;\n            _context5.prev = 2;\n            ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n            _context5.next = 9;\n            break;\n\n          case 6:\n            _context5.prev = 6;\n            _context5.t0 = _context5[\"catch\"](2);\n            throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n\n          case 9:\n            sharedSecret = ecSK.derive(ephemeralPK);\n            sharedSecretBuffer = getBufferFromBN(sharedSecret);\n            sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n            ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n\n            if (!(!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex')) {\n              _context5.next = 17;\n              break;\n            }\n\n            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n            _context5.next = 22;\n            break;\n\n          case 17:\n            if (!(cipherObject.cipherTextEncoding === 'base64')) {\n              _context5.next = 21;\n              break;\n            }\n\n            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n            _context5.next = 22;\n            break;\n\n          case 21:\n            throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(cipherObject.cipherText, \"\\\"\"));\n\n          case 22:\n            macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encodeCompressed()), cipherTextBuffer]);\n            _context5.next = 25;\n            return hmacSha256(sharedKeys.hmacKey, macData);\n\n          case 25:\n            actualMac = _context5.sent;\n            expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n            if (equalConstTime(expectedMac, actualMac)) {\n              _context5.next = 29;\n              break;\n            }\n\n            throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n\n          case 29:\n            _context5.next = 31;\n            return aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n          case 31:\n            plainText = _context5.sent;\n\n            if (!cipherObject.wasString) {\n              _context5.next = 36;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", plainText.toString());\n\n          case 36:\n            return _context5.abrupt(\"return\", plainText);\n\n          case 37:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[2, 6]]);\n  }));\n  return _decryptECIES.apply(this, arguments);\n}\n\nexport function signECDSA(privateKey, content) {\n  var contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  var ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  var publicKey = getPublicKeyFromPrivate(privateKey);\n  var contentHash = hashSha256Sync(contentBuffer);\n  var signature = ecPrivate.sign(contentHash);\n  var signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey: publicKey\n  };\n}\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n\nexport function verifyECDSA(content, publicKey, signature) {\n  var contentBuffer = getBuffer(content);\n  var ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  var contentHash = hashSha256Sync(contentBuffer);\n  return ecPublic.verify(contentHash, signature);\n}","map":{"version":3,"sources":["../../src/ec.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { ec as EllipticCurve } from 'elliptic';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nconst ecurve = new EllipticCurve('secp256k1');\nexport var InvalidPublicKeyReason;\n(function (InvalidPublicKeyReason) {\n    InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n    InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n    const cipher = await createCipher();\n    const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n    return result;\n}\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n    const cipher = await createCipher();\n    const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n    return result;\n}\nasync function hmacSha256(key, content) {\n    const hmacSha256 = await createHmacSha256();\n    return hmacSha256.digest(key, content);\n}\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for (let i = 0; i < b1.length; i++) {\n        res |= b1[i] ^ b2[i];\n    }\n    return res === 0;\n}\nfunction sharedSecretToKeys(sharedSecret) {\n    const hashedSecret = hashSha512Sync(sharedSecret);\n    return {\n        encryptionKey: hashedSecret.slice(0, 32),\n        hmacKey: hashedSecret.slice(32),\n    };\n}\nfunction allHexChars(maybe) {\n    return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\nfunction isValidPublicKey(pub) {\n    const invalidFormat = {\n        result: false,\n        reason_data: 'Invalid public key format',\n        reason: InvalidPublicKeyReason.InvalidFormat,\n    };\n    const invalidPoint = {\n        result: false,\n        reason_data: 'Public key is not a point',\n        reason: InvalidPublicKeyReason.IsNotPoint,\n    };\n    if (pub.length !== 66 && pub.length !== 130)\n        return invalidFormat;\n    const firstByte = pub.slice(0, 2);\n    if (pub.length === 130 && firstByte !== '04')\n        return invalidFormat;\n    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')\n        return invalidFormat;\n    if (!allHexChars(pub))\n        return invalidFormat;\n    const secp256k1 = new EllipticCurve('secp256k1');\n    try {\n        const keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));\n        const result = keyPair.validate();\n        return {\n            result: result.result,\n            reason_data: result.reason,\n            reason: result.result ? null : InvalidPublicKeyReason.IsNotPoint,\n        };\n    }\n    catch (e) {\n        return invalidPoint;\n    }\n}\nexport function getHexFromBN(bnInput) {\n    const hexOut = bnInput.toString('hex', 64);\n    if (hexOut.length === 64) {\n        return hexOut;\n    }\n    else if (hexOut.length < 64) {\n        const padding = '0'.repeat(64 - hexOut.length);\n        return `${padding}${hexOut}`;\n    }\n    else {\n        throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n    }\n}\nexport function getBufferFromBN(bnInput) {\n    const result = bnInput.toArrayLike(Buffer, 'be', 32);\n    if (result.byteLength !== 32) {\n        throw new Error('Failed to generate a 32-byte BN');\n    }\n    return result;\n}\nexport function getCipherObjectWrapper(opts) {\n    const shell = {\n        iv: '',\n        ephemeralPK: '',\n        mac: '',\n        cipherText: '',\n        wasString: !!opts.wasString,\n    };\n    if (opts.cipherTextEncoding === 'base64') {\n        shell.cipherTextEncoding = 'base64';\n    }\n    const ivLength = 32;\n    const ephemeralPKLength = 66;\n    const macLength = 64;\n    return {\n        payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n        payloadShell: JSON.stringify(shell),\n    };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n    const shell = {\n        signature: '',\n        publicKey: '',\n        cipherText: payloadShell,\n    };\n    const signatureLength = 144;\n    const publicKeyLength = 66;\n    return {\n        signedPayloadValuesLength: signatureLength + publicKeyLength,\n        signedPayloadShell: JSON.stringify(shell),\n    };\n}\nexport function eciesGetJsonStringLength(opts) {\n    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n    const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n    let encodedCipherTextLength;\n    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n        encodedCipherTextLength = cipherTextLength * 2;\n    }\n    else if (opts.cipherTextEncoding === 'base64') {\n        encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n    }\n    if (!opts.sign) {\n        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n    }\n    else {\n        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);\n        return (signedPayloadShell.length +\n            signedPayloadValuesLength +\n            payloadValuesLength +\n            encodedCipherTextLength);\n    }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n    const validity = isValidPublicKey(publicKey);\n    if (!validity.result) {\n        throw validity;\n    }\n    const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n    const ephemeralSK = ecurve.genKeyPair();\n    const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n    const sharedSecret = ephemeralSK.derive(ecPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const initializationVector = randomBytes(16);\n    const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n    const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n    const mac = await hmacSha256(sharedKeys.hmacKey, macData);\n    let cipherTextString;\n    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n        cipherTextString = cipherText.toString('hex');\n    }\n    else if (cipherTextEncoding === 'base64') {\n        cipherTextString = cipherText.toString('base64');\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n    }\n    const result = {\n        iv: initializationVector.toString('hex'),\n        ephemeralPK: ephemeralPK.toString('hex'),\n        cipherText: cipherTextString,\n        mac: mac.toString('hex'),\n        wasString: !!wasString,\n    };\n    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n        result.cipherTextEncoding = cipherTextEncoding;\n    }\n    return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n    const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n    let ephemeralPK = null;\n    try {\n        ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n    }\n    catch (error) {\n        throw new FailedDecryptionError('Unable to get public key from cipher object. ' +\n            'You might be trying to decrypt an unencrypted object.');\n    }\n    const sharedSecret = ecSK.derive(ephemeralPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n    let cipherTextBuffer;\n    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n        cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n    }\n    else if (cipherObject.cipherTextEncoding === 'base64') {\n        cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n    }\n    const macData = Buffer.concat([\n        ivBuffer,\n        Buffer.from(ephemeralPK.encodeCompressed()),\n        cipherTextBuffer,\n    ]);\n    const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);\n    const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n    if (!equalConstTime(expectedMac, actualMac)) {\n        throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n    }\n    const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n    if (cipherObject.wasString) {\n        return plainText.toString();\n    }\n    else {\n        return plainText;\n    }\n}\nexport function signECDSA(privateKey, content) {\n    const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n    const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n    const publicKey = getPublicKeyFromPrivate(privateKey);\n    const contentHash = hashSha256Sync(contentBuffer);\n    const signature = ecPrivate.sign(contentHash);\n    const signatureString = signature.toDER('hex');\n    return {\n        signature: signatureString,\n        publicKey,\n    };\n}\nfunction getBuffer(content) {\n    if (content instanceof Buffer)\n        return content;\n    else if (content instanceof ArrayBuffer)\n        return Buffer.from(content);\n    else\n        return Buffer.from(content);\n}\nexport function verifyECDSA(content, publicKey, signature) {\n    const contentBuffer = getBuffer(content);\n    const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n    const contentHash = hashSha256Sync(contentBuffer);\n    return ecPublic.verify(contentHash, signature);\n}\n//# sourceMappingURL=ec.js.map"]},"metadata":{},"sourceType":"module"}