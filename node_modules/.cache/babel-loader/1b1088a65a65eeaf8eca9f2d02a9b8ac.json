{"ast":null,"code":"import { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { compressPublicKey, deserializePublicKey, serializePublicKey } from './keys';\nimport { createMessageSignature } from './common';\nimport { BufferArray } from './utils';\nexport var AuthFieldType;\n\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\n\nexport function deserializeMessageSignature(bufferReader) {\n  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents\n  };\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\nexport function serializeMessageSignature(messageSignature) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\nexport function serializeTransactionAuthField(field) {\n  const bufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n\n      break;\n\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}","map":{"version":3,"sources":["../../src/signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { compressPublicKey, deserializePublicKey, serializePublicKey, } from './keys';\nimport { createMessageSignature } from './common';\nimport { BufferArray } from './utils';\nexport var AuthFieldType;\n(function (AuthFieldType) {\n    AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n    AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function deserializeMessageSignature(bufferReader) {\n    return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n    return {\n        pubKeyEncoding,\n        type: StacksMessageType.TransactionAuthField,\n        contents,\n    };\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n        throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n    });\n    switch (authFieldType) {\n        case AuthFieldType.PublicKeyCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.PublicKeyUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.SignatureCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n        case AuthFieldType.SignatureUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n        default:\n            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n    }\n}\nexport function serializeMessageSignature(messageSignature) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(messageSignature.data);\n    return bufferArray.concatBuffer();\n}\nexport function serializeTransactionAuthField(field) {\n    const bufferArray = new BufferArray();\n    switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n                bufferArray.push(serializePublicKey(field.contents));\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n                bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n            }\n            break;\n        case StacksMessageType.MessageSignature:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n            }\n            bufferArray.push(serializeMessageSignature(field.contents));\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\n//# sourceMappingURL=signature.js.map"]},"metadata":{},"sourceType":"module"}