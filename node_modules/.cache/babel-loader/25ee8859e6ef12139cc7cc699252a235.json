{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64url_1 = require(\"base64url\");\n\nvar cryptoClients_1 = require(\"./cryptoClients\");\n\nvar errors_1 = require(\"./errors\");\n\nvar sha256_1 = require(\"./cryptoClients/sha256\");\n\nvar TokenVerifier = /*#__PURE__*/function () {\n  function TokenVerifier(signingAlgorithm, rawPublicKey) {\n    _classCallCheck(this, TokenVerifier);\n\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  _createClass(TokenVerifier, [{\n    key: \"verify\",\n    value: function verify(token) {\n      if (typeof token === 'string') {\n        return this.verifyCompact(token, false);\n      } else if (typeof token === 'object') {\n        return this.verifyExpanded(token, false);\n      } else {\n        false;\n      }\n    }\n  }, {\n    key: \"verifyAsync\",\n    value: function verifyAsync(token) {\n      if (typeof token === 'string') {\n        return this.verifyCompact(token, true);\n      } else if (typeof token === 'object') {\n        return this.verifyExpanded(token, true);\n      } else {\n        return Promise.resolve(false);\n      }\n    }\n  }, {\n    key: \"verifyCompact\",\n    value: function verifyCompact(token, async) {\n      var _this = this;\n\n      // decompose the token into parts\n      var tokenParts = token.split('.'); // calculate the signing input hash\n\n      var signingInput = tokenParts[0] + '.' + tokenParts[1];\n\n      var performVerify = function performVerify(signingInputHash) {\n        // extract the signature as a DER array\n        var derSignatureBuffer = _this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n\n        return _this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, _this.rawPublicKey);\n      };\n\n      if (async) {\n        return sha256_1.hashSha256Async(signingInput).then(function (signingInputHash) {\n          return performVerify(signingInputHash);\n        });\n      } else {\n        var signingInputHash = sha256_1.hashSha256(signingInput);\n        return performVerify(signingInputHash);\n      }\n    }\n  }, {\n    key: \"verifyExpanded\",\n    value: function verifyExpanded(token, async) {\n      var _this2 = this;\n\n      var signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n      var verified = true;\n\n      var performVerify = function performVerify(signingInputHash) {\n        token['signature'].map(function (signature) {\n          var derSignatureBuffer = _this2.cryptoClient.loadSignature(signature);\n\n          var signatureVerified = _this2.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, _this2.rawPublicKey);\n\n          if (!signatureVerified) {\n            verified = false;\n          }\n        });\n        return verified;\n      };\n\n      if (async) {\n        return sha256_1.hashSha256Async(signingInput).then(function (signingInputHash) {\n          return performVerify(signingInputHash);\n        });\n      } else {\n        var signingInputHash = sha256_1.hashSha256(signingInput);\n        return performVerify(signingInputHash);\n      }\n    }\n  }]);\n\n  return TokenVerifier;\n}();\n\nexports.TokenVerifier = TokenVerifier;","map":{"version":3,"sources":["verifier.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = require(\"base64url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nclass TokenVerifier {\n    constructor(signingAlgorithm, rawPublicKey) {\n        if (!(signingAlgorithm && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw 'signing algorithm parameter must be a string';\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw 'invalid signing algorithm';\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPublicKey = rawPublicKey;\n    }\n    verify(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, false);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, false);\n        }\n        else {\n            false;\n        }\n    }\n    verifyAsync(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, true);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, true);\n        }\n        else {\n            return Promise.resolve(false);\n        }\n    }\n    verifyCompact(token, async) {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        // calculate the signing input hash\n        const signingInput = tokenParts[0] + '.' + tokenParts[1];\n        const performVerify = (signingInputHash) => {\n            // extract the signature as a DER array\n            const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);\n            // verify the signed hash\n            return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n        };\n        if (async) {\n            return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = sha256_1.hashSha256(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n    verifyExpanded(token, async) {\n        const signingInput = [\n            token['header'].join('.'),\n            base64url_1.default.encode(token['payload'])\n        ].join('.');\n        let verified = true;\n        const performVerify = (signingInputHash) => {\n            token['signature'].map((signature) => {\n                const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n                const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n                if (!signatureVerified) {\n                    verified = false;\n                }\n            });\n            return verified;\n        };\n        if (async) {\n            return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = sha256_1.hashSha256(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map"]},"metadata":{},"sourceType":"script"}