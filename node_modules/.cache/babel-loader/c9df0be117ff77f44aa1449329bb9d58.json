{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport var NodeCryptoAesCipher = /*#__PURE__*/function () {\n  function NodeCryptoAesCipher(createCipher, createDecipher) {\n    _classCallCheck(this, NodeCryptoAesCipher);\n\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  _createClass(NodeCryptoAesCipher, [{\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(algorithm, key, iv, data) {\n        var cipher, result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Unsupported cipher algorithm \\\"\".concat(algorithm, \"\\\"\"));\n\n              case 2:\n                cipher = this.createCipher(algorithm, key, iv);\n                result = Buffer.concat([cipher.update(data), cipher.final()]);\n                return _context.abrupt(\"return\", Promise.resolve(result));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function encrypt(_x, _x2, _x3, _x4) {\n        return _encrypt.apply(this, arguments);\n      }\n\n      return encrypt;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(algorithm, key, iv, data) {\n        var cipher, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Unsupported cipher algorithm \\\"\".concat(algorithm, \"\\\"\"));\n\n              case 2:\n                cipher = this.createDecipher(algorithm, key, iv);\n                result = Buffer.concat([cipher.update(data), cipher.final()]);\n                return _context2.abrupt(\"return\", Promise.resolve(result));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function decrypt(_x5, _x6, _x7, _x8) {\n        return _decrypt.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n  }]);\n\n  return NodeCryptoAesCipher;\n}();\nexport var WebCryptoAesCipher = /*#__PURE__*/function () {\n  function WebCryptoAesCipher(subtleCrypto) {\n    _classCallCheck(this, WebCryptoAesCipher);\n\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  _createClass(WebCryptoAesCipher, [{\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(algorithm, key, iv, data) {\n        var algo, length, cryptoKey, result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(algorithm === 'aes-128-cbc')) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                algo = 'AES-CBC';\n                length = 128;\n                _context3.next = 11;\n                break;\n\n              case 5:\n                if (!(algorithm === 'aes-256-cbc')) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                algo = 'AES-CBC';\n                length = 256;\n                _context3.next = 11;\n                break;\n\n              case 10:\n                throw new Error(\"Unsupported cipher algorithm \\\"\".concat(algorithm, \"\\\"\"));\n\n              case 11:\n                _context3.next = 13;\n                return this.subtleCrypto.importKey('raw', key, {\n                  name: algo,\n                  length: length\n                }, false, ['encrypt']);\n\n              case 13:\n                cryptoKey = _context3.sent;\n                _context3.next = 16;\n                return this.subtleCrypto.encrypt({\n                  name: algo,\n                  iv: iv\n                }, cryptoKey, data);\n\n              case 16:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", Buffer.from(result));\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function encrypt(_x9, _x10, _x11, _x12) {\n        return _encrypt2.apply(this, arguments);\n      }\n\n      return encrypt;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(algorithm, key, iv, data) {\n        var algo, length, cryptoKey, result;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(algorithm === 'aes-128-cbc')) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                algo = 'AES-CBC';\n                length = 128;\n                _context4.next = 11;\n                break;\n\n              case 5:\n                if (!(algorithm === 'aes-256-cbc')) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                algo = 'AES-CBC';\n                length = 256;\n                _context4.next = 11;\n                break;\n\n              case 10:\n                throw new Error(\"Unsupported cipher algorithm \\\"\".concat(algorithm, \"\\\"\"));\n\n              case 11:\n                _context4.next = 13;\n                return this.subtleCrypto.importKey('raw', key, {\n                  name: algo,\n                  length: length\n                }, false, ['decrypt']);\n\n              case 13:\n                cryptoKey = _context4.sent;\n                _context4.next = 16;\n                return this.subtleCrypto.decrypt({\n                  name: algo,\n                  iv: iv\n                }, cryptoKey, data);\n\n              case 16:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", Buffer.from(result));\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function decrypt(_x13, _x14, _x15, _x16) {\n        return _decrypt2.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n  }]);\n\n  return WebCryptoAesCipher;\n}();\nexport function createCipher() {\n  return _createCipher.apply(this, arguments);\n}\n\nfunction _createCipher() {\n  _createCipher = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var cryptoLib;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return getCryptoLib();\n\n          case 2:\n            cryptoLib = _context5.sent;\n\n            if (!(cryptoLib.name === 'subtleCrypto')) {\n              _context5.next = 7;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", new WebCryptoAesCipher(cryptoLib.lib));\n\n          case 7:\n            return _context5.abrupt(\"return\", new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv));\n\n          case 8:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _createCipher.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/aesCipher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n    constructor(createCipher, createDecipher) {\n        this.createCipher = createCipher;\n        this.createDecipher = createDecipher;\n    }\n    async encrypt(algorithm, key, iv, data) {\n        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cipher = this.createCipher(algorithm, key, iv);\n        const result = Buffer.concat([cipher.update(data), cipher.final()]);\n        return Promise.resolve(result);\n    }\n    async decrypt(algorithm, key, iv, data) {\n        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cipher = this.createDecipher(algorithm, key, iv);\n        const result = Buffer.concat([cipher.update(data), cipher.final()]);\n        return Promise.resolve(result);\n    }\n}\nexport class WebCryptoAesCipher {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async encrypt(algorithm, key, iv, data) {\n        let algo;\n        let length;\n        if (algorithm === 'aes-128-cbc') {\n            algo = 'AES-CBC';\n            length = 128;\n        }\n        else if (algorithm === 'aes-256-cbc') {\n            algo = 'AES-CBC';\n            length = 256;\n        }\n        else {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n            'encrypt',\n        ]);\n        const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\n        return Buffer.from(result);\n    }\n    async decrypt(algorithm, key, iv, data) {\n        let algo;\n        let length;\n        if (algorithm === 'aes-128-cbc') {\n            algo = 'AES-CBC';\n            length = 128;\n        }\n        else if (algorithm === 'aes-256-cbc') {\n            algo = 'AES-CBC';\n            length = 256;\n        }\n        else {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n            'decrypt',\n        ]);\n        const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\n        return Buffer.from(result);\n    }\n}\nexport async function createCipher() {\n    const cryptoLib = await getCryptoLib();\n    if (cryptoLib.name === 'subtleCrypto') {\n        return new WebCryptoAesCipher(cryptoLib.lib);\n    }\n    else {\n        return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n    }\n}\n//# sourceMappingURL=aesCipher.js.map"]},"metadata":{},"sourceType":"module"}