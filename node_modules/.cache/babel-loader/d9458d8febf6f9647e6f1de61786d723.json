{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer, intToBigInt } from '@stacks/common';\nimport { StacksTransaction } from './transaction';\nimport { StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { createTokenTransferPayload, createSmartContractPayload, createContractCallPayload } from './payload';\nimport { StandardAuthorization, SponsoredAuthorization, createSingleSigSpendingCondition, createMultiSigSpendingCondition } from './authorization';\nimport { publicKeyToString, createStacksPrivateKey, getPublicKey, publicKeyToAddress, pubKeyfromPrivKey, publicKeyFromBuffer } from './keys';\nimport { TransactionSigner } from './signer';\nimport { createSTXPostCondition, createFungiblePostCondition, createNonFungiblePostCondition } from './postcondition';\nimport { AddressHashMode, AddressVersion, PostConditionMode, PayloadType, TransactionVersion } from './constants';\nimport { createLPList, createStandardPrincipal, createContractPrincipal } from './types';\nimport { cvToHex, parseReadOnlyResponse, omit, validateTxId } from './utils';\nimport { fetchPrivate } from '@stacks/common';\nimport { validateContractCall } from './contract-abi';\nimport { c32address } from 'c32check';\nexport function getNonce(_x, _x2) {\n  return _getNonce.apply(this, arguments);\n}\n\nfunction _getNonce() {\n  _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address, network) {\n    var defaultNetwork, url, response, msg, responseText, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            defaultNetwork = new StacksMainnet();\n            url = network ? network.getAccountApiUrl(address) : defaultNetwork.getAccountApiUrl(address);\n            _context.next = 4;\n            return fetchPrivate(url);\n\n          case 4:\n            response = _context.sent;\n\n            if (response.ok) {\n              _context.next = 16;\n              break;\n            }\n\n            msg = '';\n            _context.prev = 7;\n            _context.next = 10;\n            return response.text();\n\n          case 10:\n            msg = _context.sent;\n            _context.next = 15;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](7);\n\n          case 15:\n            throw new Error(\"Error fetching nonce. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 16:\n            _context.next = 18;\n            return response.text();\n\n          case 18:\n            responseText = _context.sent;\n            result = JSON.parse(responseText);\n            return _context.abrupt(\"return\", BigInt(result.nonce));\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[7, 13]]);\n  }));\n  return _getNonce.apply(this, arguments);\n}\n\nexport function estimateTransfer(_x3, _x4) {\n  return _estimateTransfer.apply(this, arguments);\n}\n\nfunction _estimateTransfer() {\n  _estimateTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(transaction, network) {\n    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(transaction.payload.payloadType !== PayloadType.TokenTransfer)) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error(\"Transaction fee estimation only possible with \".concat(PayloadType[PayloadType.TokenTransfer], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n\n          case 2:\n            requestHeaders = {\n              Accept: 'application/text'\n            };\n            fetchOptions = {\n              method: 'GET',\n              headers: requestHeaders\n            };\n            defaultNetwork = new StacksMainnet();\n            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n            _context2.next = 8;\n            return fetchPrivate(url, fetchOptions);\n\n          case 8:\n            response = _context2.sent;\n\n            if (response.ok) {\n              _context2.next = 20;\n              break;\n            }\n\n            msg = '';\n            _context2.prev = 11;\n            _context2.next = 14;\n            return response.text();\n\n          case 14:\n            msg = _context2.sent;\n            _context2.next = 19;\n            break;\n\n          case 17:\n            _context2.prev = 17;\n            _context2.t0 = _context2[\"catch\"](11);\n\n          case 19:\n            throw new Error(\"Error estimating transaction fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 20:\n            _context2.next = 22;\n            return response.text();\n\n          case 22:\n            feeRateResult = _context2.sent;\n            txBytes = BigInt(transaction.serialize().byteLength);\n            feeRate = BigInt(feeRateResult);\n            return _context2.abrupt(\"return\", feeRate * txBytes);\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[11, 17]]);\n  }));\n  return _estimateTransfer.apply(this, arguments);\n}\n\nexport function broadcastTransaction(_x5, _x6, _x7) {\n  return _broadcastTransaction.apply(this, arguments);\n}\n\nfunction _broadcastTransaction() {\n  _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(transaction, network, attachment) {\n    var rawTx, url;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            rawTx = transaction.serialize();\n            url = network.getBroadcastApiUrl();\n            return _context3.abrupt(\"return\", broadcastRawTransaction(rawTx, url, attachment));\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _broadcastTransaction.apply(this, arguments);\n}\n\nexport function broadcastRawTransaction(_x8, _x9, _x10) {\n  return _broadcastRawTransaction.apply(this, arguments);\n}\n\nfunction _broadcastRawTransaction() {\n  _broadcastRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(rawTx, url, attachment) {\n    var options, response, text, txid, isValidTxId;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = {\n              method: 'POST',\n              headers: {\n                'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n              },\n              body: attachment ? JSON.stringify({\n                tx: rawTx.toString('hex'),\n                attachment: attachment.toString('hex')\n              }) : rawTx\n            };\n            _context4.next = 3;\n            return fetchPrivate(url, options);\n\n          case 3:\n            response = _context4.sent;\n\n            if (response.ok) {\n              _context4.next = 14;\n              break;\n            }\n\n            _context4.prev = 5;\n            _context4.next = 8;\n            return response.json();\n\n          case 8:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 11:\n            _context4.prev = 11;\n            _context4.t0 = _context4[\"catch\"](5);\n            throw Error(\"Failed to broadcast transaction: \".concat(_context4.t0.message));\n\n          case 14:\n            _context4.next = 16;\n            return response.text();\n\n          case 16:\n            text = _context4.sent;\n            txid = text.replace(/[\"]+/g, '');\n            isValidTxId = validateTxId(txid);\n\n            if (!isValidTxId) {\n              _context4.next = 23;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", {\n              txid: txid\n            });\n\n          case 23:\n            throw new Error(text);\n\n          case 24:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[5, 11]]);\n  }));\n  return _broadcastRawTransaction.apply(this, arguments);\n}\n\nexport function getAbi(_x11, _x12, _x13) {\n  return _getAbi.apply(this, arguments);\n}\n\nfunction _getAbi() {\n  _getAbi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address, contractName, network) {\n    var options, url, response, msg;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = {\n              method: 'GET'\n            };\n            url = network.getAbiApiUrl(address, contractName);\n            _context5.next = 4;\n            return fetchPrivate(url, options);\n\n          case 4:\n            response = _context5.sent;\n\n            if (response.ok) {\n              _context5.next = 16;\n              break;\n            }\n\n            msg = '';\n            _context5.prev = 7;\n            _context5.next = 10;\n            return response.text();\n\n          case 10:\n            msg = _context5.sent;\n            _context5.next = 15;\n            break;\n\n          case 13:\n            _context5.prev = 13;\n            _context5.t0 = _context5[\"catch\"](7);\n\n          case 15:\n            throw new Error(\"Error fetching contract ABI for contract \\\"\".concat(contractName, \"\\\" at address \").concat(address, \". Response \").concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 16:\n            _context5.t1 = JSON;\n            _context5.next = 19;\n            return response.text();\n\n          case 19:\n            _context5.t2 = _context5.sent;\n            return _context5.abrupt(\"return\", _context5.t1.parse.call(_context5.t1, _context5.t2));\n\n          case 21:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[7, 13]]);\n  }));\n  return _getAbi.apply(this, arguments);\n}\n\nexport function makeUnsignedSTXTokenTransfer(_x14) {\n  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);\n}\n\nfunction _makeUnsignedSTXTokenTransfer() {\n  _makeUnsignedSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(txOptions) {\n    var defaultOptions, options, payload, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            defaultOptions = {\n              fee: BigInt(0),\n              nonce: BigInt(0),\n              network: new StacksMainnet(),\n              postConditionMode: PostConditionMode.Deny,\n              memo: '',\n              sponsored: false\n            };\n            options = Object.assign(defaultOptions, txOptions);\n            payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n            authorization = null;\n            spendingCondition = null;\n\n            if ('publicKey' in options) {\n              spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n            } else {\n              spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n            }\n\n            if (options.sponsored) {\n              authorization = new SponsoredAuthorization(spendingCondition);\n            } else {\n              authorization = new StandardAuthorization(spendingCondition);\n            }\n\n            postConditions = [];\n\n            if (options.postConditions && options.postConditions.length > 0) {\n              options.postConditions.forEach(function (postCondition) {\n                postConditions.push(postCondition);\n              });\n            }\n\n            lpPostConditions = createLPList(postConditions);\n            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n            if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 14;\n            return estimateTransfer(transaction, options.network);\n\n          case 14:\n            txFee = _context6.sent;\n            transaction.setFee(txFee);\n\n          case 16:\n            if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n              _context6.next = 23;\n              break;\n            }\n\n            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n            senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n            _context6.next = 21;\n            return getNonce(senderAddress, options.network);\n\n          case 21:\n            txNonce = _context6.sent;\n            transaction.setNonce(txNonce);\n\n          case 23:\n            return _context6.abrupt(\"return\", transaction);\n\n          case 24:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);\n}\n\nexport function makeSTXTokenTransfer(_x15) {\n  return _makeSTXTokenTransfer.apply(this, arguments);\n}\n\nfunction _makeSTXTokenTransfer() {\n  _makeSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(txOptions) {\n    var publicKey, options, transaction, privKey, signer, _options, _transaction, _signer, pubKeys, _iterator, _step, _loop, _iterator2, _step2, key;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!('senderKey' in txOptions)) {\n              _context7.next = 12;\n              break;\n            }\n\n            publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n            options = omit(txOptions, 'senderKey');\n            _context7.next = 5;\n            return makeUnsignedSTXTokenTransfer(Object.assign({\n              publicKey: publicKey\n            }, options));\n\n          case 5:\n            transaction = _context7.sent;\n            privKey = createStacksPrivateKey(txOptions.senderKey);\n            signer = new TransactionSigner(transaction);\n            signer.signOrigin(privKey);\n            return _context7.abrupt(\"return\", transaction);\n\n          case 12:\n            _options = omit(txOptions, 'signerKeys');\n            _context7.next = 15;\n            return makeUnsignedSTXTokenTransfer(_options);\n\n          case 15:\n            _transaction = _context7.sent;\n            _signer = new TransactionSigner(_transaction);\n            pubKeys = txOptions.publicKeys;\n            _iterator = _createForOfIteratorHelper(txOptions.signerKeys);\n\n            try {\n              _loop = function _loop() {\n                var key = _step.value;\n                var pubKey = pubKeyfromPrivKey(key);\n                pubKeys = pubKeys.filter(function (pk) {\n                  return pk !== pubKey.data.toString('hex');\n                });\n\n                _signer.signOrigin(createStacksPrivateKey(key));\n              };\n\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            _iterator2 = _createForOfIteratorHelper(pubKeys);\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                key = _step2.value;\n\n                _signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            return _context7.abrupt(\"return\", _transaction);\n\n          case 23:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _makeSTXTokenTransfer.apply(this, arguments);\n}\n\nexport function estimateContractDeploy(_x16, _x17) {\n  return _estimateContractDeploy.apply(this, arguments);\n}\n\nfunction _estimateContractDeploy() {\n  _estimateContractDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(transaction, network) {\n    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(transaction.payload.payloadType !== PayloadType.SmartContract)) {\n              _context8.next = 2;\n              break;\n            }\n\n            throw new Error(\"Contract deploy fee estimation only possible with \".concat(PayloadType[PayloadType.SmartContract], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n\n          case 2:\n            requestHeaders = {\n              Accept: 'application/text'\n            };\n            fetchOptions = {\n              method: 'GET',\n              headers: requestHeaders\n            };\n            defaultNetwork = new StacksMainnet();\n            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n            _context8.next = 8;\n            return fetchPrivate(url, fetchOptions);\n\n          case 8:\n            response = _context8.sent;\n\n            if (response.ok) {\n              _context8.next = 20;\n              break;\n            }\n\n            msg = '';\n            _context8.prev = 11;\n            _context8.next = 14;\n            return response.text();\n\n          case 14:\n            msg = _context8.sent;\n            _context8.next = 19;\n            break;\n\n          case 17:\n            _context8.prev = 17;\n            _context8.t0 = _context8[\"catch\"](11);\n\n          case 19:\n            throw new Error(\"Error estimating contract deploy fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 20:\n            _context8.next = 22;\n            return response.text();\n\n          case 22:\n            feeRateResult = _context8.sent;\n            txBytes = intToBigInt(transaction.serialize().byteLength, false);\n            feeRate = intToBigInt(feeRateResult, false);\n            return _context8.abrupt(\"return\", feeRate * txBytes);\n\n          case 26:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[11, 17]]);\n  }));\n  return _estimateContractDeploy.apply(this, arguments);\n}\n\nexport function makeContractDeploy(_x18) {\n  return _makeContractDeploy.apply(this, arguments);\n}\n\nfunction _makeContractDeploy() {\n  _makeContractDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(txOptions) {\n    var defaultOptions, options, payload, addressHashMode, privKey, pubKey, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce, signer;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            defaultOptions = {\n              fee: BigInt(0),\n              nonce: BigInt(0),\n              network: new StacksMainnet(),\n              postConditionMode: PostConditionMode.Deny,\n              sponsored: false\n            };\n            options = Object.assign(defaultOptions, txOptions);\n            payload = createSmartContractPayload(options.contractName, options.codeBody);\n            addressHashMode = AddressHashMode.SerializeP2PKH;\n            privKey = createStacksPrivateKey(options.senderKey);\n            pubKey = getPublicKey(privKey);\n            authorization = null;\n            spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n\n            if (options.sponsored) {\n              authorization = new SponsoredAuthorization(spendingCondition);\n            } else {\n              authorization = new StandardAuthorization(spendingCondition);\n            }\n\n            postConditions = [];\n\n            if (options.postConditions && options.postConditions.length > 0) {\n              options.postConditions.forEach(function (postCondition) {\n                postConditions.push(postCondition);\n              });\n            }\n\n            lpPostConditions = createLPList(postConditions);\n            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n            if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n              _context9.next = 18;\n              break;\n            }\n\n            _context9.next = 16;\n            return estimateContractDeploy(transaction, options.network);\n\n          case 16:\n            txFee = _context9.sent;\n            transaction.setFee(txFee);\n\n          case 18:\n            if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n              _context9.next = 25;\n              break;\n            }\n\n            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n            senderAddress = publicKeyToAddress(addressVersion, pubKey);\n            _context9.next = 23;\n            return getNonce(senderAddress, options.network);\n\n          case 23:\n            txNonce = _context9.sent;\n            transaction.setNonce(txNonce);\n\n          case 25:\n            if (options.senderKey) {\n              signer = new TransactionSigner(transaction);\n              signer.signOrigin(privKey);\n            }\n\n            return _context9.abrupt(\"return\", transaction);\n\n          case 27:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _makeContractDeploy.apply(this, arguments);\n}\n\nexport function estimateContractFunctionCall(_x19, _x20) {\n  return _estimateContractFunctionCall.apply(this, arguments);\n}\n\nfunction _estimateContractFunctionCall() {\n  _estimateContractFunctionCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(transaction, network) {\n    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(transaction.payload.payloadType !== PayloadType.ContractCall)) {\n              _context10.next = 2;\n              break;\n            }\n\n            throw new Error(\"Contract call fee estimation only possible with \".concat(PayloadType[PayloadType.ContractCall], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n\n          case 2:\n            requestHeaders = {\n              Accept: 'application/text'\n            };\n            fetchOptions = {\n              method: 'GET',\n              headers: requestHeaders\n            };\n            defaultNetwork = new StacksMainnet();\n            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n            _context10.next = 8;\n            return fetchPrivate(url, fetchOptions);\n\n          case 8:\n            response = _context10.sent;\n\n            if (response.ok) {\n              _context10.next = 20;\n              break;\n            }\n\n            msg = '';\n            _context10.prev = 11;\n            _context10.next = 14;\n            return response.text();\n\n          case 14:\n            msg = _context10.sent;\n            _context10.next = 19;\n            break;\n\n          case 17:\n            _context10.prev = 17;\n            _context10.t0 = _context10[\"catch\"](11);\n\n          case 19:\n            throw new Error(\"Error estimating contract call fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 20:\n            _context10.next = 22;\n            return response.text();\n\n          case 22:\n            feeRateResult = _context10.sent;\n            txBytes = intToBigInt(transaction.serialize().byteLength, false);\n            feeRate = intToBigInt(feeRateResult, false);\n            return _context10.abrupt(\"return\", feeRate * txBytes);\n\n          case 26:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[11, 17]]);\n  }));\n  return _estimateContractFunctionCall.apply(this, arguments);\n}\n\nexport function makeUnsignedContractCall(_x21) {\n  return _makeUnsignedContractCall.apply(this, arguments);\n}\n\nfunction _makeUnsignedContractCall() {\n  _makeUnsignedContractCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txOptions) {\n    var defaultOptions, options, payload, abi, spendingCondition, authorization, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            defaultOptions = {\n              fee: BigInt(0),\n              nonce: BigInt(0),\n              network: new StacksMainnet(),\n              postConditionMode: PostConditionMode.Deny,\n              sponsored: false\n            };\n            options = Object.assign(defaultOptions, txOptions);\n            payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n\n            if (!(options === null || options === void 0 ? void 0 : options.validateWithAbi)) {\n              _context11.next = 16;\n              break;\n            }\n\n            if (!(typeof options.validateWithAbi === 'boolean')) {\n              _context11.next = 14;\n              break;\n            }\n\n            if (!(options === null || options === void 0 ? void 0 : options.network)) {\n              _context11.next = 11;\n              break;\n            }\n\n            _context11.next = 8;\n            return getAbi(options.contractAddress, options.contractName, options.network);\n\n          case 8:\n            abi = _context11.sent;\n            _context11.next = 12;\n            break;\n\n          case 11:\n            throw new Error('Network option must be provided in order to validate with ABI');\n\n          case 12:\n            _context11.next = 15;\n            break;\n\n          case 14:\n            abi = options.validateWithAbi;\n\n          case 15:\n            validateContractCall(payload, abi);\n\n          case 16:\n            spendingCondition = null;\n            authorization = null;\n\n            if ('publicKey' in options) {\n              spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n            } else {\n              spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n            }\n\n            if (options.sponsored) {\n              authorization = new SponsoredAuthorization(spendingCondition);\n            } else {\n              authorization = new StandardAuthorization(spendingCondition);\n            }\n\n            postConditions = [];\n\n            if (options.postConditions && options.postConditions.length > 0) {\n              options.postConditions.forEach(function (postCondition) {\n                postConditions.push(postCondition);\n              });\n            }\n\n            lpPostConditions = createLPList(postConditions);\n            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n            if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n              _context11.next = 29;\n              break;\n            }\n\n            _context11.next = 27;\n            return estimateContractFunctionCall(transaction, options.network);\n\n          case 27:\n            txFee = _context11.sent;\n            transaction.setFee(txFee);\n\n          case 29:\n            if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n              _context11.next = 36;\n              break;\n            }\n\n            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n            senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n            _context11.next = 34;\n            return getNonce(senderAddress, options.network);\n\n          case 34:\n            txNonce = _context11.sent;\n            transaction.setNonce(txNonce);\n\n          case 36:\n            return _context11.abrupt(\"return\", transaction);\n\n          case 37:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _makeUnsignedContractCall.apply(this, arguments);\n}\n\nexport function makeContractCall(_x22) {\n  return _makeContractCall.apply(this, arguments);\n}\n\nfunction _makeContractCall() {\n  _makeContractCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(txOptions) {\n    var publicKey, options, transaction, privKey, signer, _options2, _transaction2, _signer2, _pubKeys, _iterator3, _step3, _loop2, _iterator4, _step4, key;\n\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            if (!('senderKey' in txOptions)) {\n              _context12.next = 12;\n              break;\n            }\n\n            publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n            options = omit(txOptions, 'senderKey');\n            _context12.next = 5;\n            return makeUnsignedContractCall(Object.assign({\n              publicKey: publicKey\n            }, options));\n\n          case 5:\n            transaction = _context12.sent;\n            privKey = createStacksPrivateKey(txOptions.senderKey);\n            signer = new TransactionSigner(transaction);\n            signer.signOrigin(privKey);\n            return _context12.abrupt(\"return\", transaction);\n\n          case 12:\n            _options2 = omit(txOptions, 'signerKeys');\n            _context12.next = 15;\n            return makeUnsignedContractCall(_options2);\n\n          case 15:\n            _transaction2 = _context12.sent;\n            _signer2 = new TransactionSigner(_transaction2);\n            _pubKeys = txOptions.publicKeys;\n            _iterator3 = _createForOfIteratorHelper(txOptions.signerKeys);\n\n            try {\n              _loop2 = function _loop2() {\n                var key = _step3.value;\n                var pubKey = pubKeyfromPrivKey(key);\n                _pubKeys = _pubKeys.filter(function (pk) {\n                  return pk !== pubKey.data.toString('hex');\n                });\n\n                _signer2.signOrigin(createStacksPrivateKey(key));\n              };\n\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            _iterator4 = _createForOfIteratorHelper(_pubKeys);\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                key = _step4.value;\n\n                _signer2.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            return _context12.abrupt(\"return\", _transaction2);\n\n          case 23:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _makeContractCall.apply(this, arguments);\n}\n\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport function callReadOnlyFunction(_x23) {\n  return _callReadOnlyFunction.apply(this, arguments);\n}\n\nfunction _callReadOnlyFunction() {\n  _callReadOnlyFunction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(readOnlyFunctionOptions) {\n    var defaultOptions, options, contractName, contractAddress, functionName, functionArgs, network, senderAddress, url, args, body, response, msg;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            defaultOptions = {\n              network: new StacksMainnet()\n            };\n            options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n            contractName = options.contractName, contractAddress = options.contractAddress, functionName = options.functionName, functionArgs = options.functionArgs, network = options.network, senderAddress = options.senderAddress;\n            url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n            args = functionArgs.map(function (arg) {\n              return cvToHex(arg);\n            });\n            body = JSON.stringify({\n              sender: senderAddress,\n              arguments: args\n            });\n            _context13.next = 8;\n            return fetchPrivate(url, {\n              method: 'POST',\n              body: body,\n              headers: {\n                'Content-Type': 'application/json'\n              }\n            });\n\n          case 8:\n            response = _context13.sent;\n\n            if (response.ok) {\n              _context13.next = 20;\n              break;\n            }\n\n            msg = '';\n            _context13.prev = 11;\n            _context13.next = 14;\n            return response.text();\n\n          case 14:\n            msg = _context13.sent;\n            _context13.next = 19;\n            break;\n\n          case 17:\n            _context13.prev = 17;\n            _context13.t0 = _context13[\"catch\"](11);\n\n          case 19:\n            throw new Error(\"Error calling read-only function. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n\n          case 20:\n            return _context13.abrupt(\"return\", response.json().then(function (responseJson) {\n              return parseReadOnlyResponse(responseJson);\n            }));\n\n          case 21:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13, null, [[11, 17]]);\n  }));\n  return _callReadOnlyFunction.apply(this, arguments);\n}\n\nexport function sponsorTransaction(_x24) {\n  return _sponsorTransaction.apply(this, arguments);\n}\n\nfunction _sponsorTransaction() {\n  _sponsorTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(sponsorOptions) {\n    var _a, defaultOptions, options, network, sponsorPubKey, txFee, addressVersion, senderAddress, sponsorNonce, sponsorSpendingCondition, privKey, signer;\n\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            defaultOptions = {\n              fee: 0,\n              sponsorNonce: 0,\n              sponsorAddressHashmode: AddressHashMode.SerializeP2PKH\n            };\n            options = Object.assign(defaultOptions, sponsorOptions);\n            network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : options.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet();\n            sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n            if (!(sponsorOptions.fee === undefined || sponsorOptions.fee === null)) {\n              _context14.next = 24;\n              break;\n            }\n\n            txFee = BigInt(0);\n            _context14.t0 = options.transaction.payload.payloadType;\n            _context14.next = _context14.t0 === PayloadType.TokenTransfer ? 9 : _context14.t0 === PayloadType.SmartContract ? 13 : _context14.t0 === PayloadType.ContractCall ? 17 : 21;\n            break;\n\n          case 9:\n            _context14.next = 11;\n            return estimateTransfer(options.transaction, network);\n\n          case 11:\n            txFee = _context14.sent;\n            return _context14.abrupt(\"break\", 22);\n\n          case 13:\n            _context14.next = 15;\n            return estimateContractDeploy(options.transaction, network);\n\n          case 15:\n            txFee = _context14.sent;\n            return _context14.abrupt(\"break\", 22);\n\n          case 17:\n            _context14.next = 19;\n            return estimateContractFunctionCall(options.transaction, network);\n\n          case 19:\n            txFee = _context14.sent;\n            return _context14.abrupt(\"break\", 22);\n\n          case 21:\n            throw new Error(\"Sponsored transactions not supported for transaction type \".concat(PayloadType[options.transaction.payload.payloadType]));\n\n          case 22:\n            options.transaction.setFee(txFee);\n            options.fee = txFee;\n\n          case 24:\n            if (!(sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null)) {\n              _context14.next = 31;\n              break;\n            }\n\n            addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n            senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n            _context14.next = 29;\n            return getNonce(senderAddress, network);\n\n          case 29:\n            sponsorNonce = _context14.sent;\n            options.sponsorNonce = sponsorNonce;\n\n          case 31:\n            sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n            options.transaction.setSponsor(sponsorSpendingCondition);\n            privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n            signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n            signer.signSponsor(privKey);\n            return _context14.abrupt(\"return\", options.transaction);\n\n          case 37:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return _sponsorTransaction.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/builders.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt } from '@stacks/common';\nimport { StacksTransaction } from './transaction';\nimport { StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { createTokenTransferPayload, createSmartContractPayload, createContractCallPayload, } from './payload';\nimport { StandardAuthorization, SponsoredAuthorization, createSingleSigSpendingCondition, createMultiSigSpendingCondition, } from './authorization';\nimport { publicKeyToString, createStacksPrivateKey, getPublicKey, publicKeyToAddress, pubKeyfromPrivKey, publicKeyFromBuffer, } from './keys';\nimport { TransactionSigner } from './signer';\nimport { createSTXPostCondition, createFungiblePostCondition, createNonFungiblePostCondition, } from './postcondition';\nimport { AddressHashMode, AddressVersion, PostConditionMode, PayloadType, TransactionVersion, } from './constants';\nimport { createLPList, createStandardPrincipal, createContractPrincipal } from './types';\nimport { cvToHex, parseReadOnlyResponse, omit, validateTxId } from './utils';\nimport { fetchPrivate } from '@stacks/common';\nimport { validateContractCall } from './contract-abi';\nimport { c32address } from 'c32check';\nexport async function getNonce(address, network) {\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getAccountApiUrl(address)\n        : defaultNetwork.getAccountApiUrl(address);\n    const response = await fetchPrivate(url);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const responseText = await response.text();\n    const result = JSON.parse(responseText);\n    return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n        throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = BigInt(transaction.serialize().byteLength);\n    const feeRate = BigInt(feeRateResult);\n    return feeRate * txBytes;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n    const rawTx = transaction.serialize();\n    const url = network.getBroadcastApiUrl();\n    return broadcastRawTransaction(rawTx, url, attachment);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n    const options = {\n        method: 'POST',\n        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n        body: attachment\n            ? JSON.stringify({\n                tx: rawTx.toString('hex'),\n                attachment: attachment.toString('hex'),\n            })\n            : rawTx,\n    };\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        try {\n            return (await response.json());\n        }\n        catch (e) {\n            throw Error(`Failed to broadcast transaction: ${e.message}`);\n        }\n    }\n    const text = await response.text();\n    const txid = text.replace(/[\"]+/g, '');\n    const isValidTxId = validateTxId(txid);\n    if (isValidTxId) {\n        return {\n            txid: txid,\n        };\n    }\n    else {\n        throw new Error(text);\n    }\n}\nexport async function getAbi(address, contractName, network) {\n    const options = {\n        method: 'GET',\n    };\n    const url = network.getAbiApiUrl(address, contractName);\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return JSON.parse(await response.text());\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        memo: '',\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n    let authorization = null;\n    let spendingCondition = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateTransfer(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedSTXTokenTransfer(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport async function estimateContractDeploy(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n        throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createSmartContractPayload(options.contractName, options.codeBody);\n    const addressHashMode = AddressHashMode.SerializeP2PKH;\n    const privKey = createStacksPrivateKey(options.senderKey);\n    const pubKey = getPublicKey(privKey);\n    let authorization = null;\n    const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateContractDeploy(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    if (options.senderKey) {\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n    }\n    return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n        throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n    if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n        let abi;\n        if (typeof options.validateWithAbi === 'boolean') {\n            if (options === null || options === void 0 ? void 0 : options.network) {\n                abi = await getAbi(options.contractAddress, options.contractName, options.network);\n            }\n            else {\n                throw new Error('Network option must be provided in order to validate with ABI');\n            }\n        }\n        else {\n            abi = options.validateWithAbi;\n        }\n        validateContractCall(payload, abi);\n    }\n    let spendingCondition = null;\n    let authorization = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateContractFunctionCall(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeContractCall(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedContractCall(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedContractCall(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n    return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n    return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n    const defaultOptions = {\n        network: new StacksMainnet(),\n    };\n    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n    const { contractName, contractAddress, functionName, functionArgs, network, senderAddress } = options;\n    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n    const args = functionArgs.map(arg => cvToHex(arg));\n    const body = JSON.stringify({\n        sender: senderAddress,\n        arguments: args,\n    });\n    const response = await fetchPrivate(url, {\n        method: 'POST',\n        body,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n    var _a;\n    const defaultOptions = {\n        fee: 0,\n        sponsorNonce: 0,\n        sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    };\n    const options = Object.assign(defaultOptions, sponsorOptions);\n    const network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : (options.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet());\n    const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n        let txFee = BigInt(0);\n        switch (options.transaction.payload.payloadType) {\n            case PayloadType.TokenTransfer:\n                txFee = await estimateTransfer(options.transaction, network);\n                break;\n            case PayloadType.SmartContract:\n                txFee = await estimateContractDeploy(options.transaction, network);\n                break;\n            case PayloadType.ContractCall:\n                txFee = await estimateContractFunctionCall(options.transaction, network);\n                break;\n            default:\n                throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n        }\n        options.transaction.setFee(txFee);\n        options.fee = txFee;\n    }\n    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n        const addressVersion = network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n        const sponsorNonce = await getNonce(senderAddress, network);\n        options.sponsorNonce = sponsorNonce;\n    }\n    const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n    options.transaction.setSponsor(sponsorSpendingCondition);\n    const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n    const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n    signer.signSponsor(privKey);\n    return options.transaction;\n}\n//# sourceMappingURL=builders.js.map"]},"metadata":{},"sourceType":"module"}