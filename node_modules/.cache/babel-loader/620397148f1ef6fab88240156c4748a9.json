{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar convert = require('../converter');\n\nvar tools_1 = require('../converter/tools');\n\nvar varuint = require('../converter/varint');\n\nvar typeFields_1 = require('../typeFields');\n\nfunction psbtFromBuffer(buffer, txGetter) {\n  var offset = 0;\n\n  function varSlice() {\n    var keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    var key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n\n  function readUInt32BE() {\n    var num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n\n  function readUInt8() {\n    var num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n\n  function getKeyValue() {\n    var key = varSlice();\n    var value = varSlice();\n    return {\n      key: key,\n      value: value\n    };\n  }\n\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n\n    var isEnd = buffer.readUInt8(offset) === 0;\n\n    if (isEnd) {\n      offset++;\n    }\n\n    return isEnd;\n  }\n\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n\n  if (readUInt8() !== 0xff) {\n    throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n  }\n\n  var globalMapKeyVals = [];\n  var globalKeyIndex = {};\n\n  while (!checkEndOfKeyValPairs()) {\n    var keyVal = getKeyValue();\n    var hexKey = keyVal.key.toString('hex');\n\n    if (globalKeyIndex[hexKey]) {\n      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n    }\n\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n\n  var unsignedTxMaps = globalMapKeyVals.filter(function (keyVal) {\n    return keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX;\n  });\n\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n\n  var unsignedTx = txGetter(unsignedTxMaps[0].value); // Get input and output counts to loop the respective fields\n\n  var _unsignedTx$getInputO = unsignedTx.getInputOutputCounts(),\n      inputCount = _unsignedTx$getInputO.inputCount,\n      outputCount = _unsignedTx$getInputO.outputCount;\n\n  var inputKeyVals = [];\n  var outputKeyVals = []; // Get input fields\n\n  var _iterator = _createForOfIteratorHelper(tools_1.range(inputCount)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var index = _step.value;\n      var inputKeyIndex = {};\n      var input = [];\n\n      while (!checkEndOfKeyValPairs()) {\n        var _keyVal = getKeyValue();\n\n        var _hexKey = _keyVal.key.toString('hex');\n\n        if (inputKeyIndex[_hexKey]) {\n          throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + _hexKey);\n        }\n\n        inputKeyIndex[_hexKey] = 1;\n        input.push(_keyVal);\n      }\n\n      inputKeyVals.push(input);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(tools_1.range(outputCount)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _index = _step2.value;\n      var outputKeyIndex = {};\n      var output = [];\n\n      while (!checkEndOfKeyValPairs()) {\n        var _keyVal2 = getKeyValue();\n\n        var _hexKey2 = _keyVal2.key.toString('hex');\n\n        if (outputKeyIndex[_hexKey2]) {\n          throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + _index + ' key ' + _hexKey2);\n        }\n\n        outputKeyIndex[_hexKey2] = 1;\n        output.push(_keyVal2);\n      }\n\n      outputKeyVals.push(output);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals: globalMapKeyVals,\n    inputKeyVals: inputKeyVals,\n    outputKeyVals: outputKeyVals\n  });\n}\n\nexports.psbtFromBuffer = psbtFromBuffer;\n\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\"Format Error: Invalid \".concat(type, \" key: \").concat(keyBuf.toString('hex')));\n  }\n}\n\nexports.checkKeyBuffer = checkKeyBuffer;\n\nfunction psbtFromKeyVals(unsignedTx, _ref) {\n  var globalMapKeyVals = _ref.globalMapKeyVals,\n      inputKeyVals = _ref.inputKeyVals,\n      outputKeyVals = _ref.outputKeyVals;\n  // That was easy :-)\n  var globalMap = {\n    unsignedTx: unsignedTx\n  };\n  var txCount = 0;\n\n  var _iterator3 = _createForOfIteratorHelper(globalMapKeyVals),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var keyVal = _step3.value;\n\n      // If a globalMap item needs pubkey, uncomment\n      // const pubkey = convert.globals.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.GlobalTypes.UNSIGNED_TX:\n          checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n          if (txCount > 0) {\n            throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n          }\n\n          txCount++;\n          break;\n\n        case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n          if (globalMap.globalXpub === undefined) {\n            globalMap.globalXpub = [];\n          }\n\n          globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n          break;\n\n        default:\n          // This will allow inclusion during serialization.\n          if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n          globalMap.unknownKeyVals.push(keyVal);\n      }\n    } // Get input and output counts to loop the respective fields\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var inputCount = inputKeyVals.length;\n  var outputCount = outputKeyVals.length;\n  var inputs = [];\n  var outputs = []; // Get input fields\n\n  var _iterator4 = _createForOfIteratorHelper(tools_1.range(inputCount)),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var index = _step4.value;\n      var input = {};\n\n      var _iterator6 = _createForOfIteratorHelper(inputKeyVals[index]),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _keyVal3 = _step6.value;\n          convert.inputs.checkPubkey(_keyVal3);\n\n          switch (_keyVal3.key[0]) {\n            case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n\n              if (input.nonWitnessUtxo !== undefined) {\n                throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');\n              }\n\n              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.WITNESS_UTXO:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.WITNESS_UTXO);\n\n              if (input.witnessUtxo !== undefined) {\n                throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n              }\n\n              input.witnessUtxo = convert.inputs.witnessUtxo.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.PARTIAL_SIG:\n              if (input.partialSig === undefined) {\n                input.partialSig = [];\n              }\n\n              input.partialSig.push(convert.inputs.partialSig.decode(_keyVal3));\n              break;\n\n            case typeFields_1.InputTypes.SIGHASH_TYPE:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n\n              if (input.sighashType !== undefined) {\n                throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n              }\n\n              input.sighashType = convert.inputs.sighashType.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.REDEEM_SCRIPT:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n\n              if (input.redeemScript !== undefined) {\n                throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n              }\n\n              input.redeemScript = convert.inputs.redeemScript.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.WITNESS_SCRIPT:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n\n              if (input.witnessScript !== undefined) {\n                throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n              }\n\n              input.witnessScript = convert.inputs.witnessScript.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.BIP32_DERIVATION:\n              if (input.bip32Derivation === undefined) {\n                input.bip32Derivation = [];\n              }\n\n              input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(_keyVal3));\n              break;\n\n            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n              input.finalScriptSig = convert.inputs.finalScriptSig.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(_keyVal3);\n              break;\n\n            case typeFields_1.InputTypes.POR_COMMITMENT:\n              checkKeyBuffer('input', _keyVal3.key, typeFields_1.InputTypes.POR_COMMITMENT);\n              input.porCommitment = convert.inputs.porCommitment.decode(_keyVal3);\n              break;\n\n            default:\n              // This will allow inclusion during serialization.\n              if (!input.unknownKeyVals) input.unknownKeyVals = [];\n              input.unknownKeyVals.push(_keyVal3);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      inputs.push(input);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(tools_1.range(outputCount)),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _index2 = _step5.value;\n      var output = {};\n\n      var _iterator7 = _createForOfIteratorHelper(outputKeyVals[_index2]),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _keyVal4 = _step7.value;\n          convert.outputs.checkPubkey(_keyVal4);\n\n          switch (_keyVal4.key[0]) {\n            case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n              checkKeyBuffer('output', _keyVal4.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n\n              if (output.redeemScript !== undefined) {\n                throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n              }\n\n              output.redeemScript = convert.outputs.redeemScript.decode(_keyVal4);\n              break;\n\n            case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n              checkKeyBuffer('output', _keyVal4.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n\n              if (output.witnessScript !== undefined) {\n                throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n              }\n\n              output.witnessScript = convert.outputs.witnessScript.decode(_keyVal4);\n              break;\n\n            case typeFields_1.OutputTypes.BIP32_DERIVATION:\n              if (output.bip32Derivation === undefined) {\n                output.bip32Derivation = [];\n              }\n\n              output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(_keyVal4));\n              break;\n\n            default:\n              if (!output.unknownKeyVals) output.unknownKeyVals = [];\n              output.unknownKeyVals.push(_keyVal4);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      outputs.push(output);\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return {\n    globalMap: globalMap,\n    inputs: inputs,\n    outputs: outputs\n  };\n}\n\nexports.psbtFromKeyVals = psbtFromKeyVals;","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bip174/src/lib/parser/fromBuffer.js"],"names":["Object","defineProperty","exports","value","convert","require","tools_1","varuint","typeFields_1","psbtFromBuffer","buffer","txGetter","offset","varSlice","keyLen","decode","encodingLength","key","slice","readUInt32BE","num","readUInt8","getKeyValue","checkEndOfKeyValPairs","length","Error","isEnd","globalMapKeyVals","globalKeyIndex","keyVal","hexKey","toString","push","unsignedTxMaps","filter","GlobalTypes","UNSIGNED_TX","unsignedTx","getInputOutputCounts","inputCount","outputCount","inputKeyVals","outputKeyVals","range","index","inputKeyIndex","input","outputKeyIndex","output","psbtFromKeyVals","checkKeyBuffer","type","keyBuf","keyNum","equals","Buffer","from","globalMap","txCount","GLOBAL_XPUB","globalXpub","undefined","globals","unknownKeyVals","inputs","outputs","checkPubkey","InputTypes","NON_WITNESS_UTXO","nonWitnessUtxo","WITNESS_UTXO","witnessUtxo","PARTIAL_SIG","partialSig","SIGHASH_TYPE","sighashType","REDEEM_SCRIPT","redeemScript","WITNESS_SCRIPT","witnessScript","BIP32_DERIVATION","bip32Derivation","FINAL_SCRIPTSIG","finalScriptSig","FINAL_SCRIPTWITNESS","finalScriptWitness","POR_COMMITMENT","porCommitment","OutputTypes"],"mappings":"AAAA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAMG,YAAY,GAAGH,OAAO,CAAC,eAAD,CAA5B;;AACA,SAASI,cAAT,CAAwBC,MAAxB,EAAgCC,QAAhC,EAA0C;AACxC,MAAIC,MAAM,GAAG,CAAb;;AACA,WAASC,QAAT,GAAoB;AAClB,QAAMC,MAAM,GAAGP,OAAO,CAACQ,MAAR,CAAeL,MAAf,EAAuBE,MAAvB,CAAf;AACAA,IAAAA,MAAM,IAAIL,OAAO,CAACS,cAAR,CAAuBF,MAAvB,CAAV;AACA,QAAMG,GAAG,GAAGP,MAAM,CAACQ,KAAP,CAAaN,MAAb,EAAqBA,MAAM,GAAGE,MAA9B,CAAZ;AACAF,IAAAA,MAAM,IAAIE,MAAV;AACA,WAAOG,GAAP;AACD;;AACD,WAASE,YAAT,GAAwB;AACtB,QAAMC,GAAG,GAAGV,MAAM,CAACS,YAAP,CAAoBP,MAApB,CAAZ;AACAA,IAAAA,MAAM,IAAI,CAAV;AACA,WAAOQ,GAAP;AACD;;AACD,WAASC,SAAT,GAAqB;AACnB,QAAMD,GAAG,GAAGV,MAAM,CAACW,SAAP,CAAiBT,MAAjB,CAAZ;AACAA,IAAAA,MAAM,IAAI,CAAV;AACA,WAAOQ,GAAP;AACD;;AACD,WAASE,WAAT,GAAuB;AACrB,QAAML,GAAG,GAAGJ,QAAQ,EAApB;AACA,QAAMV,KAAK,GAAGU,QAAQ,EAAtB;AACA,WAAO;AACLI,MAAAA,GAAG,EAAHA,GADK;AAELd,MAAAA,KAAK,EAALA;AAFK,KAAP;AAID;;AACD,WAASoB,qBAAT,GAAiC;AAC/B,QAAIX,MAAM,IAAIF,MAAM,CAACc,MAArB,EAA6B;AAC3B,YAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AACD,QAAMC,KAAK,GAAGhB,MAAM,CAACW,SAAP,CAAiBT,MAAjB,MAA6B,CAA3C;;AACA,QAAIc,KAAJ,EAAW;AACTd,MAAAA,MAAM;AACP;;AACD,WAAOc,KAAP;AACD;;AACD,MAAIP,YAAY,OAAO,UAAvB,EAAmC;AACjC,UAAM,IAAIM,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,MAAIJ,SAAS,OAAO,IAApB,EAA0B;AACxB,UAAM,IAAII,KAAJ,CACJ,+DADI,CAAN;AAGD;;AACD,MAAME,gBAAgB,GAAG,EAAzB;AACA,MAAMC,cAAc,GAAG,EAAvB;;AACA,SAAO,CAACL,qBAAqB,EAA7B,EAAiC;AAC/B,QAAMM,MAAM,GAAGP,WAAW,EAA1B;AACA,QAAMQ,MAAM,GAAGD,MAAM,CAACZ,GAAP,CAAWc,QAAX,CAAoB,KAApB,CAAf;;AACA,QAAIH,cAAc,CAACE,MAAD,CAAlB,EAA4B;AAC1B,YAAM,IAAIL,KAAJ,CACJ,8DAA8DK,MAD1D,CAAN;AAGD;;AACDF,IAAAA,cAAc,CAACE,MAAD,CAAd,GAAyB,CAAzB;AACAH,IAAAA,gBAAgB,CAACK,IAAjB,CAAsBH,MAAtB;AACD;;AACD,MAAMI,cAAc,GAAGN,gBAAgB,CAACO,MAAjB,CACrB,UAAAL,MAAM;AAAA,WAAIA,MAAM,CAACZ,GAAP,CAAW,CAAX,MAAkBT,YAAY,CAAC2B,WAAb,CAAyBC,WAA/C;AAAA,GADe,CAAvB;;AAGA,MAAIH,cAAc,CAACT,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,UAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACD;;AACD,MAAMY,UAAU,GAAG1B,QAAQ,CAACsB,cAAc,CAAC,CAAD,CAAd,CAAkB9B,KAAnB,CAA3B,CAhEwC,CAiExC;;AACA,8BAAoCkC,UAAU,CAACC,oBAAX,EAApC;AAAA,MAAQC,UAAR,yBAAQA,UAAR;AAAA,MAAoBC,WAApB,yBAAoBA,WAApB;;AACA,MAAMC,YAAY,GAAG,EAArB;AACA,MAAMC,aAAa,GAAG,EAAtB,CApEwC,CAqExC;;AArEwC,6CAsEpBpC,OAAO,CAACqC,KAAR,CAAcJ,UAAd,CAtEoB;AAAA;;AAAA;AAsExC,wDAA+C;AAAA,UAApCK,KAAoC;AAC7C,UAAMC,aAAa,GAAG,EAAtB;AACA,UAAMC,KAAK,GAAG,EAAd;;AACA,aAAO,CAACvB,qBAAqB,EAA7B,EAAiC;AAC/B,YAAMM,OAAM,GAAGP,WAAW,EAA1B;;AACA,YAAMQ,OAAM,GAAGD,OAAM,CAACZ,GAAP,CAAWc,QAAX,CAAoB,KAApB,CAAf;;AACA,YAAIc,aAAa,CAACf,OAAD,CAAjB,EAA2B;AACzB,gBAAM,IAAIL,KAAJ,CACJ,uDACE,cADF,GAEEmB,KAFF,GAGE,OAHF,GAIEd,OALE,CAAN;AAOD;;AACDe,QAAAA,aAAa,CAACf,OAAD,CAAb,GAAwB,CAAxB;AACAgB,QAAAA,KAAK,CAACd,IAAN,CAAWH,OAAX;AACD;;AACDY,MAAAA,YAAY,CAACT,IAAb,CAAkBc,KAAlB;AACD;AAzFuC;AAAA;AAAA;AAAA;AAAA;;AAAA,8CA0FpBxC,OAAO,CAACqC,KAAR,CAAcH,WAAd,CA1FoB;AAAA;;AAAA;AA0FxC,2DAAgD;AAAA,UAArCI,MAAqC;AAC9C,UAAMG,cAAc,GAAG,EAAvB;AACA,UAAMC,MAAM,GAAG,EAAf;;AACA,aAAO,CAACzB,qBAAqB,EAA7B,EAAiC;AAC/B,YAAMM,QAAM,GAAGP,WAAW,EAA1B;;AACA,YAAMQ,QAAM,GAAGD,QAAM,CAACZ,GAAP,CAAWc,QAAX,CAAoB,KAApB,CAAf;;AACA,YAAIgB,cAAc,CAACjB,QAAD,CAAlB,EAA4B;AAC1B,gBAAM,IAAIL,KAAJ,CACJ,wDACE,eADF,GAEEmB,MAFF,GAGE,OAHF,GAIEd,QALE,CAAN;AAOD;;AACDiB,QAAAA,cAAc,CAACjB,QAAD,CAAd,GAAyB,CAAzB;AACAkB,QAAAA,MAAM,CAAChB,IAAP,CAAYH,QAAZ;AACD;;AACDa,MAAAA,aAAa,CAACV,IAAd,CAAmBgB,MAAnB;AACD;AA7GuC;AAAA;AAAA;AAAA;AAAA;;AA8GxC,SAAOC,eAAe,CAACZ,UAAD,EAAa;AACjCV,IAAAA,gBAAgB,EAAhBA,gBADiC;AAEjCc,IAAAA,YAAY,EAAZA,YAFiC;AAGjCC,IAAAA,aAAa,EAAbA;AAHiC,GAAb,CAAtB;AAKD;;AACDxC,OAAO,CAACO,cAAR,GAAyBA,cAAzB;;AACA,SAASyC,cAAT,CAAwBC,IAAxB,EAA8BC,MAA9B,EAAsCC,MAAtC,EAA8C;AAC5C,MAAI,CAACD,MAAM,CAACE,MAAP,CAAcC,MAAM,CAACC,IAAP,CAAY,CAACH,MAAD,CAAZ,CAAd,CAAL,EAA2C;AACzC,UAAM,IAAI5B,KAAJ,iCACqB0B,IADrB,mBACkCC,MAAM,CAACrB,QAAP,CAAgB,KAAhB,CADlC,EAAN;AAGD;AACF;;AACD7B,OAAO,CAACgD,cAAR,GAAyBA,cAAzB;;AACA,SAASD,eAAT,CACEZ,UADF,QAGE;AAAA,MADEV,gBACF,QADEA,gBACF;AAAA,MADoBc,YACpB,QADoBA,YACpB;AAAA,MADkCC,aAClC,QADkCA,aAClC;AACA;AACA,MAAMe,SAAS,GAAG;AAChBpB,IAAAA,UAAU,EAAVA;AADgB,GAAlB;AAGA,MAAIqB,OAAO,GAAG,CAAd;;AALA,8CAMqB/B,gBANrB;AAAA;;AAAA;AAMA,2DAAuC;AAAA,UAA5BE,MAA4B;;AACrC;AACA;AACA,cAAQA,MAAM,CAACZ,GAAP,CAAW,CAAX,CAAR;AACE,aAAKT,YAAY,CAAC2B,WAAb,CAAyBC,WAA9B;AACEc,UAAAA,cAAc,CACZ,QADY,EAEZrB,MAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2B,WAAb,CAAyBC,WAHb,CAAd;;AAKA,cAAIsB,OAAO,GAAG,CAAd,EAAiB;AACf,kBAAM,IAAIjC,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACDiC,UAAAA,OAAO;AACP;;AACF,aAAKlD,YAAY,CAAC2B,WAAb,CAAyBwB,WAA9B;AACE,cAAIF,SAAS,CAACG,UAAV,KAAyBC,SAA7B,EAAwC;AACtCJ,YAAAA,SAAS,CAACG,UAAV,GAAuB,EAAvB;AACD;;AACDH,UAAAA,SAAS,CAACG,UAAV,CAAqB5B,IAArB,CAA0B5B,OAAO,CAAC0D,OAAR,CAAgBF,UAAhB,CAA2B7C,MAA3B,CAAkCc,MAAlC,CAA1B;AACA;;AACF;AACE;AACA,cAAI,CAAC4B,SAAS,CAACM,cAAf,EAA+BN,SAAS,CAACM,cAAV,GAA2B,EAA3B;AAC/BN,UAAAA,SAAS,CAACM,cAAV,CAAyB/B,IAAzB,CAA8BH,MAA9B;AArBJ;AAuBD,KAhCD,CAiCA;;AAjCA;AAAA;AAAA;AAAA;AAAA;;AAkCA,MAAMU,UAAU,GAAGE,YAAY,CAACjB,MAAhC;AACA,MAAMgB,WAAW,GAAGE,aAAa,CAAClB,MAAlC;AACA,MAAMwC,MAAM,GAAG,EAAf;AACA,MAAMC,OAAO,GAAG,EAAhB,CArCA,CAsCA;;AAtCA,8CAuCoB3D,OAAO,CAACqC,KAAR,CAAcJ,UAAd,CAvCpB;AAAA;;AAAA;AAuCA,2DAA+C;AAAA,UAApCK,KAAoC;AAC7C,UAAME,KAAK,GAAG,EAAd;;AAD6C,kDAExBL,YAAY,CAACG,KAAD,CAFY;AAAA;;AAAA;AAE7C,+DAA0C;AAAA,cAA/Bf,QAA+B;AACxCzB,UAAAA,OAAO,CAAC4D,MAAR,CAAeE,WAAf,CAA2BrC,QAA3B;;AACA,kBAAQA,QAAM,CAACZ,GAAP,CAAW,CAAX,CAAR;AACE,iBAAKT,YAAY,CAAC2D,UAAb,CAAwBC,gBAA7B;AACElB,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBC,gBAHZ,CAAd;;AAKA,kBAAItB,KAAK,CAACuB,cAAN,KAAyBR,SAA7B,EAAwC;AACtC,sBAAM,IAAIpC,KAAJ,CACJ,mDADI,CAAN;AAGD;;AACDqB,cAAAA,KAAK,CAACuB,cAAN,GAAuBjE,OAAO,CAAC4D,MAAR,CAAeK,cAAf,CAA8BtD,MAA9B,CAAqCc,QAArC,CAAvB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBG,YAA7B;AACEpB,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBG,YAHZ,CAAd;;AAKA,kBAAIxB,KAAK,CAACyB,WAAN,KAAsBV,SAA1B,EAAqC;AACnC,sBAAM,IAAIpC,KAAJ,CAAU,+CAAV,CAAN;AACD;;AACDqB,cAAAA,KAAK,CAACyB,WAAN,GAAoBnE,OAAO,CAAC4D,MAAR,CAAeO,WAAf,CAA2BxD,MAA3B,CAAkCc,QAAlC,CAApB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBK,WAA7B;AACE,kBAAI1B,KAAK,CAAC2B,UAAN,KAAqBZ,SAAzB,EAAoC;AAClCf,gBAAAA,KAAK,CAAC2B,UAAN,GAAmB,EAAnB;AACD;;AACD3B,cAAAA,KAAK,CAAC2B,UAAN,CAAiBzC,IAAjB,CAAsB5B,OAAO,CAAC4D,MAAR,CAAeS,UAAf,CAA0B1D,MAA1B,CAAiCc,QAAjC,CAAtB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBO,YAA7B;AACExB,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBO,YAHZ,CAAd;;AAKA,kBAAI5B,KAAK,CAAC6B,WAAN,KAAsBd,SAA1B,EAAqC;AACnC,sBAAM,IAAIpC,KAAJ,CAAU,+CAAV,CAAN;AACD;;AACDqB,cAAAA,KAAK,CAAC6B,WAAN,GAAoBvE,OAAO,CAAC4D,MAAR,CAAeW,WAAf,CAA2B5D,MAA3B,CAAkCc,QAAlC,CAApB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBS,aAA7B;AACE1B,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBS,aAHZ,CAAd;;AAKA,kBAAI9B,KAAK,CAAC+B,YAAN,KAAuBhB,SAA3B,EAAsC;AACpC,sBAAM,IAAIpC,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACDqB,cAAAA,KAAK,CAAC+B,YAAN,GAAqBzE,OAAO,CAAC4D,MAAR,CAAea,YAAf,CAA4B9D,MAA5B,CAAmCc,QAAnC,CAArB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBW,cAA7B;AACE5B,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBW,cAHZ,CAAd;;AAKA,kBAAIhC,KAAK,CAACiC,aAAN,KAAwBlB,SAA5B,EAAuC;AACrC,sBAAM,IAAIpC,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACDqB,cAAAA,KAAK,CAACiC,aAAN,GAAsB3E,OAAO,CAAC4D,MAAR,CAAee,aAAf,CAA6BhE,MAA7B,CAAoCc,QAApC,CAAtB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBa,gBAA7B;AACE,kBAAIlC,KAAK,CAACmC,eAAN,KAA0BpB,SAA9B,EAAyC;AACvCf,gBAAAA,KAAK,CAACmC,eAAN,GAAwB,EAAxB;AACD;;AACDnC,cAAAA,KAAK,CAACmC,eAAN,CAAsBjD,IAAtB,CACE5B,OAAO,CAAC4D,MAAR,CAAeiB,eAAf,CAA+BlE,MAA/B,CAAsCc,QAAtC,CADF;AAGA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBe,eAA7B;AACEhC,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBe,eAHZ,CAAd;AAKApC,cAAAA,KAAK,CAACqC,cAAN,GAAuB/E,OAAO,CAAC4D,MAAR,CAAemB,cAAf,CAA8BpE,MAA9B,CAAqCc,QAArC,CAAvB;AACA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBiB,mBAA7B;AACElC,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBiB,mBAHZ,CAAd;AAKAtC,cAAAA,KAAK,CAACuC,kBAAN,GAA2BjF,OAAO,CAAC4D,MAAR,CAAeqB,kBAAf,CAAkCtE,MAAlC,CACzBc,QADyB,CAA3B;AAGA;;AACF,iBAAKrB,YAAY,CAAC2D,UAAb,CAAwBmB,cAA7B;AACEpC,cAAAA,cAAc,CACZ,OADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAAC2D,UAAb,CAAwBmB,cAHZ,CAAd;AAKAxC,cAAAA,KAAK,CAACyC,aAAN,GAAsBnF,OAAO,CAAC4D,MAAR,CAAeuB,aAAf,CAA6BxE,MAA7B,CAAoCc,QAApC,CAAtB;AACA;;AACF;AACE;AACA,kBAAI,CAACiB,KAAK,CAACiB,cAAX,EAA2BjB,KAAK,CAACiB,cAAN,GAAuB,EAAvB;AAC3BjB,cAAAA,KAAK,CAACiB,cAAN,CAAqB/B,IAArB,CAA0BH,QAA1B;AArGJ;AAuGD;AA3G4C;AAAA;AAAA;AAAA;AAAA;;AA4G7CmC,MAAAA,MAAM,CAAChC,IAAP,CAAYc,KAAZ;AACD;AApJD;AAAA;AAAA;AAAA;AAAA;;AAAA,8CAqJoBxC,OAAO,CAACqC,KAAR,CAAcH,WAAd,CArJpB;AAAA;;AAAA;AAqJA,2DAAgD;AAAA,UAArCI,OAAqC;AAC9C,UAAMI,MAAM,GAAG,EAAf;;AAD8C,kDAEzBN,aAAa,CAACE,OAAD,CAFY;AAAA;;AAAA;AAE9C,+DAA2C;AAAA,cAAhCf,QAAgC;AACzCzB,UAAAA,OAAO,CAAC6D,OAAR,CAAgBC,WAAhB,CAA4BrC,QAA5B;;AACA,kBAAQA,QAAM,CAACZ,GAAP,CAAW,CAAX,CAAR;AACE,iBAAKT,YAAY,CAACgF,WAAb,CAAyBZ,aAA9B;AACE1B,cAAAA,cAAc,CACZ,QADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAACgF,WAAb,CAAyBZ,aAHb,CAAd;;AAKA,kBAAI5B,MAAM,CAAC6B,YAAP,KAAwBhB,SAA5B,EAAuC;AACrC,sBAAM,IAAIpC,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACDuB,cAAAA,MAAM,CAAC6B,YAAP,GAAsBzE,OAAO,CAAC6D,OAAR,CAAgBY,YAAhB,CAA6B9D,MAA7B,CAAoCc,QAApC,CAAtB;AACA;;AACF,iBAAKrB,YAAY,CAACgF,WAAb,CAAyBV,cAA9B;AACE5B,cAAAA,cAAc,CACZ,QADY,EAEZrB,QAAM,CAACZ,GAFK,EAGZT,YAAY,CAACgF,WAAb,CAAyBV,cAHb,CAAd;;AAKA,kBAAI9B,MAAM,CAAC+B,aAAP,KAAyBlB,SAA7B,EAAwC;AACtC,sBAAM,IAAIpC,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACDuB,cAAAA,MAAM,CAAC+B,aAAP,GAAuB3E,OAAO,CAAC6D,OAAR,CAAgBc,aAAhB,CAA8BhE,MAA9B,CAAqCc,QAArC,CAAvB;AACA;;AACF,iBAAKrB,YAAY,CAACgF,WAAb,CAAyBR,gBAA9B;AACE,kBAAIhC,MAAM,CAACiC,eAAP,KAA2BpB,SAA/B,EAA0C;AACxCb,gBAAAA,MAAM,CAACiC,eAAP,GAAyB,EAAzB;AACD;;AACDjC,cAAAA,MAAM,CAACiC,eAAP,CAAuBjD,IAAvB,CACE5B,OAAO,CAAC6D,OAAR,CAAgBgB,eAAhB,CAAgClE,MAAhC,CAAuCc,QAAvC,CADF;AAGA;;AACF;AACE,kBAAI,CAACmB,MAAM,CAACe,cAAZ,EAA4Bf,MAAM,CAACe,cAAP,GAAwB,EAAxB;AAC5Bf,cAAAA,MAAM,CAACe,cAAP,CAAsB/B,IAAtB,CAA2BH,QAA3B;AAjCJ;AAmCD;AAvC6C;AAAA;AAAA;AAAA;AAAA;;AAwC9CoC,MAAAA,OAAO,CAACjC,IAAR,CAAagB,MAAb;AACD;AA9LD;AAAA;AAAA;AAAA;AAAA;;AA+LA,SAAO;AAAES,IAAAA,SAAS,EAATA,SAAF;AAAaO,IAAAA,MAAM,EAANA,MAAb;AAAqBC,IAAAA,OAAO,EAAPA;AAArB,GAAP;AACD;;AACD/D,OAAO,CAAC+C,eAAR,GAA0BA,eAA1B","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n"]},"metadata":{},"sourceType":"script"}