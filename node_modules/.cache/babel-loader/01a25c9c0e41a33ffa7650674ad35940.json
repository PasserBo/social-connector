{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\nimport { c32ToB58 } from 'c32check';\nexport function doSignaturesMatchPublicKeys(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  var publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    var publicKey = publicKeys[0];\n\n    try {\n      var tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\nexport function doPublicKeysMatchIssuer(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  var publicKeys = payload.public_keys;\n  var addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    var addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\nexport function doPublicKeysMatchUsername(_x, _x2) {\n  return _doPublicKeysMatchUsername.apply(this, arguments);\n}\n\nfunction _doPublicKeysMatchUsername() {\n  _doPublicKeysMatchUsername = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(token, nameLookupURL) {\n    var payload, username, url, response, responseText, responseJSON, nameOwningAddress, nameOwningAddressBtc, addressFromIssuer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            payload = decodeToken(token).payload;\n\n            if (!(typeof payload === 'string')) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error('Unexpected token payload type of string');\n\n          case 4:\n            if (payload.username) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", true);\n\n          case 6:\n            if (!(payload.username === null)) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt(\"return\", true);\n\n          case 8:\n            if (!(nameLookupURL === null)) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 10:\n            username = payload.username;\n            url = \"\".concat(nameLookupURL.replace(/\\/$/, ''), \"/\").concat(username);\n            _context.next = 14;\n            return fetchPrivate(url);\n\n          case 14:\n            response = _context.sent;\n            _context.next = 17;\n            return response.text();\n\n          case 17:\n            responseText = _context.sent;\n            responseJSON = JSON.parse(responseText);\n\n            if (!responseJSON.hasOwnProperty('address')) {\n              _context.next = 31;\n              break;\n            }\n\n            nameOwningAddress = responseJSON.address;\n            nameOwningAddressBtc = nameOwningAddress;\n\n            try {\n              nameOwningAddressBtc = c32ToB58(nameOwningAddress, 0);\n            } catch (_a) {}\n\n            addressFromIssuer = getAddressFromDID(payload.iss);\n\n            if (!(nameOwningAddressBtc === addressFromIssuer)) {\n              _context.next = 28;\n              break;\n            }\n\n            return _context.abrupt(\"return\", true);\n\n          case 28:\n            return _context.abrupt(\"return\", false);\n\n          case 29:\n            _context.next = 32;\n            break;\n\n          case 31:\n            return _context.abrupt(\"return\", false);\n\n          case 32:\n            _context.next = 39;\n            break;\n\n          case 34:\n            _context.prev = 34;\n            _context.t0 = _context[\"catch\"](0);\n            console.log(_context.t0);\n            console.log('Error checking `doPublicKeysMatchUsername`');\n            return _context.abrupt(\"return\", false);\n\n          case 39:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 34]]);\n  }));\n  return _doPublicKeysMatchUsername.apply(this, arguments);\n}\n\nexport function isIssuanceDateValid(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    var issuedAt = new Date(payload.iat * 1000);\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isExpirationDateValid(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    var expiresAt = new Date(payload.exp * 1000);\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isManifestUriValid(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n  var payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport function verifyAuthRequest(_x3) {\n  return _verifyAuthRequest.apply(this, arguments);\n}\n\nfunction _verifyAuthRequest() {\n  _verifyAuthRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(token) {\n    var values;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(decodeToken(token).header.alg === 'none')) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error('Token must be signed in order to be verified');\n\n          case 2:\n            _context2.next = 4;\n            return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n\n          case 4:\n            values = _context2.sent;\n            return _context2.abrupt(\"return\", values.every(function (val) {\n              return val;\n            }));\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifyAuthRequest.apply(this, arguments);\n}\n\nexport function verifyAuthRequestAndLoadManifest(_x4) {\n  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);\n}\n\nfunction _verifyAuthRequestAndLoadManifest() {\n  _verifyAuthRequestAndLoadManifest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(token) {\n    var valid;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return verifyAuthRequest(token);\n\n          case 2:\n            valid = _context3.sent;\n\n            if (valid) {\n              _context3.next = 5;\n              break;\n            }\n\n            throw new Error('Token is an invalid auth request');\n\n          case 5:\n            return _context3.abrupt(\"return\", fetchAppManifest(token));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);\n}\n\nexport function verifyAuthResponse(_x5, _x6, _x7) {\n  return _verifyAuthResponse.apply(this, arguments);\n}\n\nfunction _verifyAuthResponse() {\n  _verifyAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(token, nameLookupURL, fallbackLookupURLs) {\n    var values, usernameMatchings, someUsernameMatches;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token)]);\n\n          case 2:\n            values = _context4.sent;\n            _context4.next = 5;\n            return Promise.all([nameLookupURL].concat(fallbackLookupURLs || []).map(function (url) {\n              return doPublicKeysMatchUsername(token, url);\n            }));\n\n          case 5:\n            usernameMatchings = _context4.sent;\n            someUsernameMatches = usernameMatchings.includes(true);\n            return _context4.abrupt(\"return\", !!someUsernameMatches && values.every(function (val) {\n              return val;\n            }));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _verifyAuthResponse.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/verification.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\nimport { c32ToB58 } from 'c32check';\nexport function doSignaturesMatchPublicKeys(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    if (publicKeys.length === 1) {\n        const publicKey = publicKeys[0];\n        try {\n            const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n            return tokenVerifier.verify(token);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n}\nexport function doPublicKeysMatchIssuer(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    const addressFromIssuer = getAddressFromDID(payload.iss);\n    if (publicKeys.length === 1) {\n        const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n        if (addressFromPublicKeys === addressFromIssuer) {\n            return true;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n    return false;\n}\nexport async function doPublicKeysMatchUsername(token, nameLookupURL) {\n    try {\n        const payload = decodeToken(token).payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        if (!payload.username) {\n            return true;\n        }\n        if (payload.username === null) {\n            return true;\n        }\n        if (nameLookupURL === null) {\n            return false;\n        }\n        const username = payload.username;\n        const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n        const response = await fetchPrivate(url);\n        const responseText = await response.text();\n        const responseJSON = JSON.parse(responseText);\n        if (responseJSON.hasOwnProperty('address')) {\n            const nameOwningAddress = responseJSON.address;\n            let nameOwningAddressBtc = nameOwningAddress;\n            try {\n                nameOwningAddressBtc = c32ToB58(nameOwningAddress, 0);\n            }\n            catch (_a) { }\n            const addressFromIssuer = getAddressFromDID(payload.iss);\n            if (nameOwningAddressBtc === addressFromIssuer) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Error checking `doPublicKeysMatchUsername`');\n        return false;\n    }\n}\nexport function isIssuanceDateValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.iat) {\n        if (typeof payload.iat !== 'number') {\n            return false;\n        }\n        const issuedAt = new Date(payload.iat * 1000);\n        if (new Date().getTime() < issuedAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexport function isExpirationDateValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.exp) {\n        if (typeof payload.exp !== 'number') {\n            return false;\n        }\n        const expiresAt = new Date(payload.exp * 1000);\n        if (new Date().getTime() > expiresAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexport function isManifestUriValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport async function verifyAuthRequest(token) {\n    if (decodeToken(token).header.alg === 'none') {\n        throw new Error('Token must be signed in order to be verified');\n    }\n    const values = await Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n        isManifestUriValid(token),\n        isRedirectUriValid(token),\n    ]);\n    return values.every(val => val);\n}\nexport async function verifyAuthRequestAndLoadManifest(token) {\n    const valid = await verifyAuthRequest(token);\n    if (!valid) {\n        throw new Error('Token is an invalid auth request');\n    }\n    return fetchAppManifest(token);\n}\nexport async function verifyAuthResponse(token, nameLookupURL, fallbackLookupURLs) {\n    const values = await Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n    ]);\n    const usernameMatchings = await Promise.all([nameLookupURL]\n        .concat(fallbackLookupURLs || [])\n        .map(url => doPublicKeysMatchUsername(token, url)));\n    const someUsernameMatches = usernameMatchings.includes(true);\n    return !!someUsernameMatches && values.every(val => val);\n}\n//# sourceMappingURL=verification.js.map"]},"metadata":{},"sourceType":"module"}