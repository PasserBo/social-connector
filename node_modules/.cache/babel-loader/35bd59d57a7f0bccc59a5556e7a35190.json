{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport var NodeCryptoPbkdf2 = /*#__PURE__*/function () {\n  function NodeCryptoPbkdf2(nodePbkdf2) {\n    _classCallCheck(this, NodeCryptoPbkdf2);\n\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  _createClass(NodeCryptoPbkdf2, [{\n    key: \"derive\",\n    value: function () {\n      var _derive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(password, salt, iterations, keyLength, digest) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(digest !== 'sha512' && digest !== 'sha256')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Unsupported digest \\\"\".concat(digest, \"\\\" for Pbkdf2\"));\n\n              case 2:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.nodePbkdf2(password, salt, iterations, keyLength, digest, function (error, result) {\n                    if (error) {\n                      reject(error);\n                    }\n\n                    resolve(result);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function derive(_x, _x2, _x3, _x4, _x5) {\n        return _derive.apply(this, arguments);\n      }\n\n      return derive;\n    }()\n  }]);\n\n  return NodeCryptoPbkdf2;\n}();\nexport var WebCryptoPbkdf2 = /*#__PURE__*/function () {\n  function WebCryptoPbkdf2(subtleCrypto) {\n    _classCallCheck(this, WebCryptoPbkdf2);\n\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  _createClass(WebCryptoPbkdf2, [{\n    key: \"derive\",\n    value: function () {\n      var _derive2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(password, salt, iterations, keyLength, digest) {\n        var algo, result, passwordBytes, key, partialWebCrypto;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(digest === 'sha256')) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                algo = 'SHA-256';\n                _context2.next = 9;\n                break;\n\n              case 4:\n                if (!(digest === 'sha512')) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                algo = 'SHA-512';\n                _context2.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Unsupported Pbkdf2 digest algorithm \\\"\".concat(digest, \"\\\"\"));\n\n              case 9:\n                passwordBytes = Buffer.from(password, 'utf8');\n                _context2.prev = 10;\n                _context2.next = 13;\n                return this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n\n              case 13:\n                key = _context2.sent;\n                _context2.next = 16;\n                return this.subtleCrypto.deriveBits({\n                  name: 'PBKDF2',\n                  salt: salt,\n                  iterations: iterations,\n                  hash: {\n                    name: algo\n                  }\n                }, key, keyLength * 8);\n\n              case 16:\n                result = _context2.sent;\n                _context2.next = 23;\n                break;\n\n              case 19:\n                _context2.prev = 19;\n                _context2.t0 = _context2[\"catch\"](10);\n                partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n                return _context2.abrupt(\"return\", partialWebCrypto.derive(password, salt, iterations, keyLength, digest));\n\n              case 23:\n                return _context2.abrupt(\"return\", Buffer.from(result));\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[10, 19]]);\n      }));\n\n      function derive(_x6, _x7, _x8, _x9, _x10) {\n        return _derive2.apply(this, arguments);\n      }\n\n      return derive;\n    }()\n  }]);\n\n  return WebCryptoPbkdf2;\n}();\nexport var WebCryptoPartialPbkdf2 = /*#__PURE__*/function () {\n  function WebCryptoPartialPbkdf2(subtleCrypto) {\n    _classCallCheck(this, WebCryptoPartialPbkdf2);\n\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  _createClass(WebCryptoPartialPbkdf2, [{\n    key: \"derive\",\n    value: function () {\n      var _derive3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(password, salt, iterations, keyLength, digest) {\n        var _this2 = this;\n\n        var key, algo, algoOpts, hmacDigest, DK, saltLength, block1, destPos, hLen, l, writeUInt32BE, i, T, U, j, k;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                writeUInt32BE = function _writeUInt32BE(data, value, offset) {\n                  value = +value;\n                  offset >>>= 0;\n                  data[offset] = value >>> 24;\n                  data[offset + 1] = value >>> 16;\n                  data[offset + 2] = value >>> 8;\n                  data[offset + 3] = value & 0xff;\n                  return offset + 4;\n                };\n\n                if (!(digest !== 'sha512' && digest !== 'sha256')) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Unsupported digest \\\"\".concat(digest, \"\\\" for Pbkdf2\"));\n\n              case 3:\n                key = Buffer.from(password, 'utf8');\n                algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n                algoOpts = {\n                  name: 'HMAC',\n                  hash: algo\n                };\n\n                hmacDigest = function hmacDigest(key, data) {\n                  return _this2.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(function (cryptoKey) {\n                    return _this2.subtleCrypto.sign(algoOpts, cryptoKey, data);\n                  }).then(function (result) {\n                    return new Uint8Array(result);\n                  });\n                };\n\n                DK = new Uint8Array(keyLength);\n                saltLength = salt.length;\n                block1 = new Uint8Array(saltLength + 4);\n                block1.set(salt);\n                destPos = 0;\n                hLen = digest === 'sha512' ? 64 : 32;\n                l = Math.ceil(keyLength / hLen);\n                i = 1;\n\n              case 15:\n                if (!(i <= l)) {\n                  _context3.next = 35;\n                  break;\n                }\n\n                writeUInt32BE(block1, i, saltLength);\n                _context3.next = 19;\n                return hmacDigest(key, block1);\n\n              case 19:\n                T = _context3.sent;\n                U = T;\n                j = 1;\n\n              case 22:\n                if (!(j < iterations)) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                _context3.next = 25;\n                return hmacDigest(key, U);\n\n              case 25:\n                U = _context3.sent;\n\n                for (k = 0; k < hLen; k++) {\n                  T[k] ^= U[k];\n                }\n\n              case 27:\n                j++;\n                _context3.next = 22;\n                break;\n\n              case 30:\n                DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n                destPos += hLen;\n\n              case 32:\n                i++;\n                _context3.next = 15;\n                break;\n\n              case 35:\n                return _context3.abrupt(\"return\", Buffer.from(DK.buffer));\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function derive(_x11, _x12, _x13, _x14, _x15) {\n        return _derive3.apply(this, arguments);\n      }\n\n      return derive;\n    }()\n  }]);\n\n  return WebCryptoPartialPbkdf2;\n}();\nexport function createPbkdf2() {\n  return _createPbkdf.apply(this, arguments);\n}\n\nfunction _createPbkdf() {\n  _createPbkdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var cryptoLib;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return getCryptoLib();\n\n          case 2:\n            cryptoLib = _context4.sent;\n\n            if (!(cryptoLib.name === 'subtleCrypto')) {\n              _context4.next = 7;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", new WebCryptoPbkdf2(cryptoLib.lib));\n\n          case 7:\n            return _context4.abrupt(\"return\", new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _createPbkdf.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/pbkdf2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoPbkdf2 {\n    constructor(nodePbkdf2) {\n        this.nodePbkdf2 = nodePbkdf2;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        if (digest !== 'sha512' && digest !== 'sha256') {\n            throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n        }\n        return new Promise((resolve, reject) => {\n            this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n                if (error) {\n                    reject(error);\n                }\n                resolve(result);\n            });\n        });\n    }\n}\nexport class WebCryptoPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        let algo;\n        if (digest === 'sha256') {\n            algo = 'SHA-256';\n        }\n        else if (digest === 'sha512') {\n            algo = 'SHA-512';\n        }\n        else {\n            throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n        }\n        let result;\n        const passwordBytes = Buffer.from(password, 'utf8');\n        try {\n            const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [\n                'deriveBits',\n            ]);\n            result = await this.subtleCrypto.deriveBits({\n                name: 'PBKDF2',\n                salt,\n                iterations,\n                hash: { name: algo },\n            }, key, keyLength * 8);\n        }\n        catch (error) {\n            const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n            return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n        }\n        return Buffer.from(result);\n    }\n}\nexport class WebCryptoPartialPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        if (digest !== 'sha512' && digest !== 'sha256') {\n            throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n        }\n        const key = Buffer.from(password, 'utf8');\n        const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n        const algoOpts = { name: 'HMAC', hash: algo };\n        const hmacDigest = (key, data) => this.subtleCrypto\n            .importKey('raw', key, algoOpts, true, ['sign'])\n            .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n            .then(result => new Uint8Array(result));\n        const DK = new Uint8Array(keyLength);\n        const saltLength = salt.length;\n        const block1 = new Uint8Array(saltLength + 4);\n        block1.set(salt);\n        let destPos = 0;\n        const hLen = digest === 'sha512' ? 64 : 32;\n        const l = Math.ceil(keyLength / hLen);\n        function writeUInt32BE(data, value, offset) {\n            value = +value;\n            offset >>>= 0;\n            data[offset] = value >>> 24;\n            data[offset + 1] = value >>> 16;\n            data[offset + 2] = value >>> 8;\n            data[offset + 3] = value & 0xff;\n            return offset + 4;\n        }\n        for (let i = 1; i <= l; i++) {\n            writeUInt32BE(block1, i, saltLength);\n            const T = await hmacDigest(key, block1);\n            let U = T;\n            for (let j = 1; j < iterations; j++) {\n                U = await hmacDigest(key, U);\n                for (let k = 0; k < hLen; k++) {\n                    T[k] ^= U[k];\n                }\n            }\n            DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n            destPos += hLen;\n        }\n        return Buffer.from(DK.buffer);\n    }\n}\nexport async function createPbkdf2() {\n    const cryptoLib = await getCryptoLib();\n    if (cryptoLib.name === 'subtleCrypto') {\n        return new WebCryptoPbkdf2(cryptoLib.lib);\n    }\n    else {\n        return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n    }\n}\n//# sourceMappingURL=pbkdf2.js.map"]},"metadata":{},"sourceType":"module"}