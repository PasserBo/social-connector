{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer } from '@stacks/common';\nimport { encryptECIES, decryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport function encryptContent(_x, _x2) {\n  return _encryptContent.apply(this, arguments);\n}\n\nfunction _encryptContent() {\n  _encryptContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(content, options) {\n    var opts, privateKey, wasString, contentBuffer, cipherObject, cipherPayload, signatureObject, signedCipherObject;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            opts = Object.assign({}, options);\n\n            if (opts.publicKey) {\n              _context.next = 5;\n              break;\n            }\n\n            if (opts.privateKey) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error('Either public key or private key must be supplied for encryption.');\n\n          case 4:\n            opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n\n          case 5:\n            if (typeof opts.wasString === 'boolean') {\n              wasString = opts.wasString;\n            } else {\n              wasString = typeof content === 'string';\n            }\n\n            contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n            _context.next = 9;\n            return encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n\n          case 9:\n            cipherObject = _context.sent;\n            cipherPayload = JSON.stringify(cipherObject);\n\n            if (opts.sign) {\n              if (typeof opts.sign === 'string') {\n                privateKey = opts.sign;\n              } else if (!privateKey) {\n                privateKey = opts.privateKey;\n              }\n\n              signatureObject = signECDSA(privateKey, cipherPayload);\n              signedCipherObject = {\n                signature: signatureObject.signature,\n                publicKey: signatureObject.publicKey,\n                cipherText: cipherPayload\n              };\n              cipherPayload = JSON.stringify(signedCipherObject);\n            }\n\n            return _context.abrupt(\"return\", cipherPayload);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _encryptContent.apply(this, arguments);\n}\n\nexport function decryptContent(content, options) {\n  var opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    var cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"sources":["../../src/encryption.ts"],"names":[],"mappings":";;AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAGE,YAHF,EAIE,YAJF,EAKE,SALF,QAMO,MANP;AAQA,SAAS,uBAAT,QAAwC,QAAxC;AAiDA,gBAAsB,cAAtB;AAAA;AAAA;;;6EAAO,iBACL,OADK,EAEL,OAFK;AAAA;AAAA;AAAA;AAAA;AAAA;AAIC,YAAA,IAJD,GAIQ,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAJR;;AAAA,gBAMA,IAAI,CAAC,SANL;AAAA;AAAA;AAAA;;AAAA,gBAOE,IAAI,CAAC,UAPP;AAAA;AAAA;AAAA;;AAAA,kBAQK,IAAI,KAAJ,CAAU,mEAAV,CARL;;AAAA;AAUH,YAAA,IAAI,CAAC,SAAL,GAAiB,uBAAuB,CAAC,IAAI,CAAC,UAAN,CAAxC;;AAVG;AAaL,gBAAI,OAAO,IAAI,CAAC,SAAZ,KAA0B,SAA9B,EAAyC;AACvC,cAAA,SAAS,GAAG,IAAI,CAAC,SAAjB;AACD,aAFD,MAEO;AACL,cAAA,SAAS,GAAG,OAAO,OAAP,KAAmB,QAA/B;AACD;;AACK,YAAA,aAlBD,GAkBiB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,MAAM,CAAC,IAAP,CAAY,OAAZ,CAA9B,GAAqD,OAlBtE;AAAA;AAAA,mBAmBsB,YAAY,CACrC,IAAI,CAAC,SADgC,EAErC,aAFqC,EAGrC,SAHqC,EAIrC,IAAI,CAAC,kBAJgC,CAnBlC;;AAAA;AAmBC,YAAA,YAnBD;AAyBD,YAAA,aAzBC,GAyBe,IAAI,CAAC,SAAL,CAAe,YAAf,CAzBf;;AA0BL,gBAAI,IAAI,CAAC,IAAT,EAAe;AACb,kBAAI,OAAO,IAAI,CAAC,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,gBAAA,UAAU,GAAG,IAAI,CAAC,IAAlB;AACD,eAFD,MAEO,IAAI,CAAC,UAAL,EAAiB;AACtB,gBAAA,UAAU,GAAG,IAAI,CAAC,UAAlB;AACD;;AACK,cAAA,eANO,GAMW,SAAS,CAAC,UAAD,EAAc,aAAd,CANpB;AAOP,cAAA,kBAPO,GAOkC;AAC7C,gBAAA,SAAS,EAAE,eAAe,CAAC,SADkB;AAE7C,gBAAA,SAAS,EAAE,eAAe,CAAC,SAFkB;AAG7C,gBAAA,UAAU,EAAE;AAHiC,eAPlC;AAYb,cAAA,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,CAAhB;AACD;;AAvCI,6CAwCE,aAxCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAoDP,OAAM,SAAU,cAAV,CACJ,OADI,EAEJ,OAFI,EAIH;AAED,MAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAb;;AACA,MAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAI;AACF,QAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,OAAX,CAArB;AACA,WAAO,YAAY,CAAC,IAAI,CAAC,UAAN,EAAkB,YAAlB,CAAnB;AACD,GAHD,CAGE,OAAO,GAAP,EAAY;AACZ,QAAI,GAAG,YAAY,WAAnB,EAAgC;AAC9B,YAAM,IAAI,KAAJ,CACJ,iEACE,iEAFE,CAAN;AAID,KALD,MAKO;AACL,YAAM,GAAN;AACD;AACF;AACF","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { encryptECIES, decryptECIES, signECDSA, } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    let privateKey;\n    if (!opts.publicKey) {\n        if (!opts.privateKey) {\n            throw new Error('Either public key or private key must be supplied for encryption.');\n        }\n        opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n    }\n    let wasString;\n    if (typeof opts.wasString === 'boolean') {\n        wasString = opts.wasString;\n    }\n    else {\n        wasString = typeof content === 'string';\n    }\n    const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n    const cipherObject = await encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n    let cipherPayload = JSON.stringify(cipherObject);\n    if (opts.sign) {\n        if (typeof opts.sign === 'string') {\n            privateKey = opts.sign;\n        }\n        else if (!privateKey) {\n            privateKey = opts.privateKey;\n        }\n        const signatureObject = signECDSA(privateKey, cipherPayload);\n        const signedCipherObject = {\n            signature: signatureObject.signature,\n            publicKey: signatureObject.publicKey,\n            cipherText: cipherPayload,\n        };\n        cipherPayload = JSON.stringify(signedCipherObject);\n    }\n    return cipherPayload;\n}\nexport function decryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n        throw new Error('Private key is required for decryption.');\n    }\n    try {\n        const cipherObject = JSON.parse(content);\n        return decryptECIES(opts.privateKey, cipherObject);\n    }\n    catch (err) {\n        if (err instanceof SyntaxError) {\n            throw new Error('Failed to parse encrypted content JSON. The content may not ' +\n                'be encrypted. If using getFile, try passing { decrypt: false }.');\n        }\n        else {\n            throw err;\n        }\n    }\n}\n//# sourceMappingURL=encryption.js.map"]},"metadata":{},"sourceType":"module"}