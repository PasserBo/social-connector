{"ast":null,"code":"import { AddressHashMode, AddressVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, TransactionVersion } from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\nexport function createMessageSignature(signature) {\n  const length = Buffer.from(signature, 'hex').byteLength;\n\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature\n  };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\nexport function addressFromVersionHash(version, hash) {\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: hash\n  };\n}\nexport function addressToString(address) {\n  return c32address(address.version, address.hash160).toString();\n}","map":{"version":3,"sources":["../../src/common.ts"],"names":[],"mappings":"AAAA,SACE,eADF,EAEE,cAFF,EAGE,kCAHF,EAIE,iBAJF,EAKE,kBALF,QAMO,aANP;AAOA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,UAAT,QAA2B,UAA3B;AAaA,OAAM,SAAU,sBAAV,CAAiC,SAAjC,EAAkD;AACtD,QAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,KAAvB,EAA8B,UAA7C;;AACA,MAAI,MAAM,IAAI,kCAAd,EAAkD;AAChD,UAAM,KAAK,CAAC,mBAAD,CAAX;AACD;;AAED,SAAO;AACL,IAAA,IAAI,EAAE,iBAAiB,CAAC,gBADnB;AAEL,IAAA,IAAI,EAAE;AAFD,GAAP;AAID;AAMD,OAAM,SAAU,wBAAV,CACJ,QADI,EAEJ,SAFI,EAEyB;AAE7B,UAAQ,QAAR;AACE,SAAK,eAAe,CAAC,cAArB;AACE,cAAQ,SAAR;AACE,aAAK,kBAAkB,CAAC,OAAxB;AACE,iBAAO,cAAc,CAAC,gBAAtB;;AACF,aAAK,kBAAkB,CAAC,OAAxB;AACE,iBAAO,cAAc,CAAC,gBAAtB;;AACF;AACE,gBAAM,IAAI,KAAJ,CACJ,wBAAwB,IAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,iBAAiB,QAAQ,EADtE,CAAN;AANJ;;AAUF,SAAK,eAAe,CAAC,aAArB;AACA,SAAK,eAAe,CAAC,eAArB;AACA,SAAK,eAAe,CAAC,cAArB;AACE,cAAQ,SAAR;AACE,aAAK,kBAAkB,CAAC,OAAxB;AACE,iBAAO,cAAc,CAAC,eAAtB;;AACF,aAAK,kBAAkB,CAAC,OAAxB;AACE,iBAAO,cAAc,CAAC,eAAtB;;AACF;AACE,gBAAM,IAAI,KAAJ,CACJ,wBAAwB,IAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,iBAAiB,QAAQ,EADtE,CAAN;AANJ;;AAUF;AACE,YAAM,IAAI,KAAJ,CAAU,uBAAuB,IAAI,CAAC,SAAL,CAAe,QAAf,CAAwB,EAAzD,CAAN;AA1BJ;AA4BD;AAED,OAAM,SAAU,sBAAV,CAAiC,OAAjC,EAA0D,IAA1D,EAAsE;AAC1E,SAAO;AAAE,IAAA,IAAI,EAAE,iBAAiB,CAAC,OAA1B;AAAmC,IAAA,OAAnC;AAA4C,IAAA,OAAO,EAAE;AAArD,GAAP;AACD;AAED,OAAM,SAAU,eAAV,CAA0B,OAA1B,EAA0C;AAC9C,SAAO,UAAU,CAAC,OAAO,CAAC,OAAT,EAAkB,OAAO,CAAC,OAA1B,CAAV,CAA6C,QAA7C,EAAP;AACD","sourceRoot":"","sourcesContent":["import { AddressHashMode, AddressVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, TransactionVersion, } from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\nexport function createMessageSignature(signature) {\n    const length = Buffer.from(signature, 'hex').byteLength;\n    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n        throw Error('Invalid signature');\n    }\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: signature,\n    };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n    switch (hashMode) {\n        case AddressHashMode.SerializeP2PKH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetSingleSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetSingleSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        case AddressHashMode.SerializeP2SH:\n        case AddressHashMode.SerializeP2WPKH:\n        case AddressHashMode.SerializeP2WSH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetMultiSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetMultiSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        default:\n            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n    }\n}\nexport function addressFromVersionHash(version, hash) {\n    return { type: StacksMessageType.Address, version, hash160: hash };\n}\nexport function addressToString(address) {\n    return c32address(address.version, address.hash160).toString();\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}