{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, StacksMessageType, TransactionVersion, PubKeyEncoding } from './constants';\nimport { BufferArray, hash160, hashP2PKH, hexStringToInt, intToHexString, leftPadHexToLength, randomBytes } from './utils';\nimport { ec as EC } from 'elliptic';\nimport { createMessageSignature } from './authorization';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\nexport function getAddressFromPrivateKey(privateKey) {\n  var transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  var pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey) {\n  var transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  var addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  var addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  var addrString = addressToString(addr);\n  return addrString;\n}\nexport function createStacksPublicKey(key) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex')\n  };\n}\nexport function publicKeyFromSignature(message, messageSignature) {\n  var pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  var ec = new EC('secp256k1');\n  var messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);\n  var parsedSignature = parseRecoverableSignature(messageSignature.data);\n  var publicKey = ec.recoverPubKey(messageBN, parsedSignature, parsedSignature.recoveryParam, 'hex');\n\n  if (pubKeyEncoding == PubKeyEncoding.Uncompressed) {\n    return publicKey.encode('hex');\n  }\n\n  return publicKey.encodeCompressed('hex');\n}\nexport function publicKeyFromBuffer(data) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: data\n  };\n}\nexport function isCompressed(key) {\n  return !key.data.toString('hex').startsWith('04');\n}\nexport function publicKeyToString(key) {\n  return key.data.toString('hex');\n}\nexport function serializePublicKey(key) {\n  var bufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n  var privKey = createStacksPrivateKey(privateKey);\n  var ec = new EC('secp256k1');\n  var keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n  var pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n  return createStacksPublicKey(pubKey);\n}\nexport function compressPublicKey(publicKey) {\n  var ec = new EC('secp256k1');\n  var key = ec.keyFromPublic(publicKey);\n  var pubKey = key.getPublic(true, 'hex');\n  return createStacksPublicKey(pubKey);\n}\nexport function deserializePublicKey(bufferReader) {\n  var fieldId = bufferReader.readUInt8();\n  var keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n  var data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n  var compressed;\n\n  if (data.length === 33) {\n    if (data[data.length - 1] !== 1) {\n      throw new Error('Improperly formatted private-key. 33 byte length usually ' + 'indicates compressed key, but last byte must be == 0x01');\n    }\n\n    compressed = true;\n  } else if (data.length === 32) {\n    compressed = false;\n  } else {\n    throw new Error(\"Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length \".concat(data.length));\n  }\n\n  return {\n    data: data,\n    compressed: compressed\n  };\n}\nexport function makeRandomPrivKey(entropy) {\n  var ec = new EC('secp256k1');\n  var options = {\n    entropy: entropy || randomBytes(32)\n  };\n  var keyPair = ec.genKeyPair(options);\n  var privateKey = keyPair.getPrivate().toString('hex', 32);\n  return createStacksPrivateKey(privateKey);\n}\nexport function signWithKey(privateKey, input) {\n  var ec = new EC('secp256k1');\n  var key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n  var signature = key.sign(input, 'hex', {\n    canonical: true\n  });\n  var coordinateValueBytes = 32;\n  var r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n  var s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n\n  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n    throw new Error('\"signature.recoveryParam\" is not set');\n  }\n\n  var recoveryParam = intToHexString(signature.recoveryParam, 1);\n  var recoverableSignatureString = recoveryParam + r + s;\n  return createMessageSignature(recoverableSignatureString);\n}\nexport function getSignatureRecoveryParam(signature) {\n  var coordinateValueBytes = 32;\n\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n\n  var recoveryParamHex = signature.substr(0, 2);\n  return hexStringToInt(recoveryParamHex);\n}\nexport function parseRecoverableSignature(signature) {\n  var coordinateValueBytes = 32;\n\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n\n  var recoveryParamHex = signature.substr(0, 2);\n  var r = signature.substr(2, coordinateValueBytes * 2);\n  var s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n  return {\n    recoveryParam: hexStringToInt(recoveryParamHex),\n    r: r,\n    s: s\n  };\n}\nexport function getPublicKey(privateKey) {\n  return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n  return privateKey.data.toString('hex');\n}\nexport function publicKeyToAddress(version, publicKey) {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}","map":{"version":3,"sources":["../../src/keys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, StacksMessageType, TransactionVersion, PubKeyEncoding, } from './constants';\nimport { BufferArray, hash160, hashP2PKH, hexStringToInt, intToHexString, leftPadHexToLength, randomBytes, } from './utils';\nimport { ec as EC } from 'elliptic';\nimport { createMessageSignature } from './authorization';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\nexport function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion.Mainnet) {\n    const pubKey = pubKeyfromPrivKey(privateKey);\n    return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion.Mainnet) {\n    publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n    const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n    const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n    const addrString = addressToString(addr);\n    return addrString;\n}\nexport function createStacksPublicKey(key) {\n    return {\n        type: StacksMessageType.PublicKey,\n        data: Buffer.from(key, 'hex'),\n    };\n}\nexport function publicKeyFromSignature(message, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {\n    const ec = new EC('secp256k1');\n    const messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);\n    const parsedSignature = parseRecoverableSignature(messageSignature.data);\n    const publicKey = ec.recoverPubKey(messageBN, parsedSignature, parsedSignature.recoveryParam, 'hex');\n    if (pubKeyEncoding == PubKeyEncoding.Uncompressed) {\n        return publicKey.encode('hex');\n    }\n    return publicKey.encodeCompressed('hex');\n}\nexport function publicKeyFromBuffer(data) {\n    return { type: StacksMessageType.PublicKey, data };\n}\nexport function isCompressed(key) {\n    return !key.data.toString('hex').startsWith('04');\n}\nexport function publicKeyToString(key) {\n    return key.data.toString('hex');\n}\nexport function serializePublicKey(key) {\n    const bufferArray = new BufferArray();\n    bufferArray.push(key.data);\n    return bufferArray.concatBuffer();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n    const privKey = createStacksPrivateKey(privateKey);\n    const ec = new EC('secp256k1');\n    const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n    const pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n    return createStacksPublicKey(pubKey);\n}\nexport function compressPublicKey(publicKey) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPublic(publicKey);\n    const pubKey = key.getPublic(true, 'hex');\n    return createStacksPublicKey(pubKey);\n}\nexport function deserializePublicKey(bufferReader) {\n    const fieldId = bufferReader.readUInt8();\n    const keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n    return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n    const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n    let compressed;\n    if (data.length === 33) {\n        if (data[data.length - 1] !== 1) {\n            throw new Error('Improperly formatted private-key. 33 byte length usually ' +\n                'indicates compressed key, but last byte must be == 0x01');\n        }\n        compressed = true;\n    }\n    else if (data.length === 32) {\n        compressed = false;\n    }\n    else {\n        throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`);\n    }\n    return { data, compressed };\n}\nexport function makeRandomPrivKey(entropy) {\n    const ec = new EC('secp256k1');\n    const options = { entropy: entropy || randomBytes(32) };\n    const keyPair = ec.genKeyPair(options);\n    const privateKey = keyPair.getPrivate().toString('hex', 32);\n    return createStacksPrivateKey(privateKey);\n}\nexport function signWithKey(privateKey, input) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n    const signature = key.sign(input, 'hex', { canonical: true });\n    const coordinateValueBytes = 32;\n    const r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n    const s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n    if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n        throw new Error('\"signature.recoveryParam\" is not set');\n    }\n    const recoveryParam = intToHexString(signature.recoveryParam, 1);\n    const recoverableSignatureString = recoveryParam + r + s;\n    return createMessageSignature(recoverableSignatureString);\n}\nexport function getSignatureRecoveryParam(signature) {\n    const coordinateValueBytes = 32;\n    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n        throw new Error('Invalid signature');\n    }\n    const recoveryParamHex = signature.substr(0, 2);\n    return hexStringToInt(recoveryParamHex);\n}\nexport function parseRecoverableSignature(signature) {\n    const coordinateValueBytes = 32;\n    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n        throw new Error('Invalid signature');\n    }\n    const recoveryParamHex = signature.substr(0, 2);\n    const r = signature.substr(2, coordinateValueBytes * 2);\n    const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n    return {\n        recoveryParam: hexStringToInt(recoveryParamHex),\n        r,\n        s,\n    };\n}\nexport function getPublicKey(privateKey) {\n    return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n    return privateKey.data.toString('hex');\n}\nexport function publicKeyToAddress(version, publicKey) {\n    return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n//# sourceMappingURL=keys.js.map"]},"metadata":{},"sourceType":"module"}