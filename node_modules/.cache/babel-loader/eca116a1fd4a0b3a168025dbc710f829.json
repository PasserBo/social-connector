{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Buffer } from '@stacks/common';\nimport 'cross-fetch/polyfill';\nimport { TokenSigner, SECP256K1Client } from 'jsontokens';\nimport { makeUUID4, nextMonth, getGlobalObject } from '@stacks/common';\nimport { makeDIDFromAddress } from './dids';\nimport { encryptECIES, decryptECIES, makeECPrivateKey, publicKeyToAddress } from '@stacks/encryption';\nimport { DEFAULT_SCOPE } from './constants';\nvar VERSION = '1.3.1';\nexport function generateTransitKey() {\n  var transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI) {\n  var scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SCOPE.slice();\n  var appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  var getWindowOrigin = function getWindowOrigin(paramName) {\n    var location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: \"makeAuthRequest([\".concat(paramName, \"=undefined])\")\n    });\n    return location === null || location === void 0 ? void 0 : location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = \"\".concat(getWindowOrigin('redirectURI'), \"/\");\n  }\n\n  if (!manifestURI) {\n    manifestURI = \"\".concat(getWindowOrigin('manifestURI'), \"/manifest.json\");\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  var payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes: scopes\n  });\n  var publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  var address = publicKeyToAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  var tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  var token = tokenSigner.sign(payload);\n  return token;\n}\nexport function encryptPrivateKey(_x, _x2) {\n  return _encryptPrivateKey.apply(this, arguments);\n}\n\nfunction _encryptPrivateKey() {\n  _encryptPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(publicKey, privateKey) {\n    var encryptedObj, encryptedJSON;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return encryptECIES(publicKey, Buffer.from(privateKey), true);\n\n          case 2:\n            encryptedObj = _context.sent;\n            encryptedJSON = JSON.stringify(encryptedObj);\n            return _context.abrupt(\"return\", Buffer.from(encryptedJSON).toString('hex'));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _encryptPrivateKey.apply(this, arguments);\n}\n\nexport function decryptPrivateKey(_x3, _x4) {\n  return _decryptPrivateKey.apply(this, arguments);\n}\n\nfunction _decryptPrivateKey() {\n  _decryptPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(privateKey, hexedEncrypted) {\n    var unhexedString, encryptedObj, decrypted;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n            encryptedObj = JSON.parse(unhexedString);\n            _context2.next = 4;\n            return decryptECIES(privateKey, encryptedObj);\n\n          case 4:\n            decrypted = _context2.sent;\n\n            if (!(typeof decrypted !== 'string')) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('Unable to correctly decrypt private key');\n\n          case 9:\n            return _context2.abrupt(\"return\", decrypted);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decryptPrivateKey.apply(this, arguments);\n}\n\nexport function makeAuthResponse(_x5) {\n  return _makeAuthResponse.apply(this, arguments);\n}\n\nfunction _makeAuthResponse() {\n  _makeAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(privateKey) {\n    var profile,\n        username,\n        metadata,\n        coreToken,\n        appPrivateKey,\n        expiresAt,\n        transitPublicKey,\n        hubUrl,\n        blockstackAPIUrl,\n        associationToken,\n        publicKey,\n        address,\n        privateKeyPayload,\n        coreTokenPayload,\n        additionalProperties,\n        payload,\n        tokenSigner,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            profile = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            username = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;\n            metadata = _args3.length > 3 ? _args3[3] : undefined;\n            coreToken = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;\n            appPrivateKey = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : null;\n            expiresAt = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : nextMonth().getTime();\n            transitPublicKey = _args3.length > 7 && _args3[7] !== undefined ? _args3[7] : null;\n            hubUrl = _args3.length > 8 && _args3[8] !== undefined ? _args3[8] : null;\n            blockstackAPIUrl = _args3.length > 9 && _args3[9] !== undefined ? _args3[9] : null;\n            associationToken = _args3.length > 10 && _args3[10] !== undefined ? _args3[10] : null;\n            publicKey = SECP256K1Client.derivePublicKey(privateKey);\n            address = publicKeyToAddress(publicKey);\n            privateKeyPayload = appPrivateKey;\n            coreTokenPayload = coreToken;\n            additionalProperties = {};\n\n            if (!(appPrivateKey !== undefined && appPrivateKey !== null)) {\n              _context3.next = 27;\n              break;\n            }\n\n            if (!(transitPublicKey !== undefined && transitPublicKey !== null)) {\n              _context3.next = 24;\n              break;\n            }\n\n            _context3.next = 19;\n            return encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n          case 19:\n            privateKeyPayload = _context3.sent;\n\n            if (!(coreToken !== undefined && coreToken !== null)) {\n              _context3.next = 24;\n              break;\n            }\n\n            _context3.next = 23;\n            return encryptPrivateKey(transitPublicKey, coreToken);\n\n          case 23:\n            coreTokenPayload = _context3.sent;\n\n          case 24:\n            additionalProperties = {\n              email: (metadata === null || metadata === void 0 ? void 0 : metadata.email) ? metadata.email : null,\n              profile_url: (metadata === null || metadata === void 0 ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,\n              hubUrl: hubUrl,\n              blockstackAPIUrl: blockstackAPIUrl,\n              associationToken: associationToken,\n              version: VERSION\n            };\n            _context3.next = 27;\n            break;\n\n          case 27:\n            payload = Object.assign({}, {\n              jti: makeUUID4(),\n              iat: Math.floor(new Date().getTime() / 1000),\n              exp: Math.floor(expiresAt / 1000),\n              iss: makeDIDFromAddress(address),\n              private_key: privateKeyPayload,\n              public_keys: [publicKey],\n              profile: profile,\n              username: username,\n              core_token: coreTokenPayload\n            }, additionalProperties);\n            tokenSigner = new TokenSigner('ES256k', privateKey);\n            return _context3.abrupt(\"return\", tokenSigner.sign(payload));\n\n          case 30:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _makeAuthResponse.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/messages.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport 'cross-fetch/polyfill';\nimport { TokenSigner, SECP256K1Client } from 'jsontokens';\nimport { makeUUID4, nextMonth, getGlobalObject } from '@stacks/common';\nimport { makeDIDFromAddress } from './dids';\nimport { encryptECIES, decryptECIES, makeECPrivateKey, publicKeyToAddress, } from '@stacks/encryption';\nimport { DEFAULT_SCOPE } from './constants';\nconst VERSION = '1.3.1';\nexport function generateTransitKey() {\n    const transitKey = makeECPrivateKey();\n    return transitKey;\n}\nexport function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = DEFAULT_SCOPE.slice(), appDomain, expiresAt = nextMonth().getTime(), extraParams = {}) {\n    const getWindowOrigin = (paramName) => {\n        const location = getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n        });\n        return location === null || location === void 0 ? void 0 : location.origin;\n    };\n    if (!redirectURI) {\n        redirectURI = `${getWindowOrigin('redirectURI')}/`;\n    }\n    if (!manifestURI) {\n        manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n    }\n    if (!appDomain) {\n        appDomain = getWindowOrigin('appDomain');\n    }\n    const payload = Object.assign({}, extraParams, {\n        jti: makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: null,\n        public_keys: [],\n        domain_name: appDomain,\n        manifest_uri: manifestURI,\n        redirect_uri: redirectURI,\n        version: VERSION,\n        do_not_include_profile: true,\n        supports_hub_url: true,\n        scopes,\n    });\n    const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n    payload.public_keys = [publicKey];\n    const address = publicKeyToAddress(publicKey);\n    payload.iss = makeDIDFromAddress(address);\n    const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n    const token = tokenSigner.sign(payload);\n    return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n    const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n    const encryptedJSON = JSON.stringify(encryptedObj);\n    return Buffer.from(encryptedJSON).toString('hex');\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n    const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n    const encryptedObj = JSON.parse(unhexedString);\n    const decrypted = await decryptECIES(privateKey, encryptedObj);\n    if (typeof decrypted !== 'string') {\n        throw new Error('Unable to correctly decrypt private key');\n    }\n    else {\n        return decrypted;\n    }\n}\nexport async function makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n    const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n    const address = publicKeyToAddress(publicKey);\n    let privateKeyPayload = appPrivateKey;\n    let coreTokenPayload = coreToken;\n    let additionalProperties = {};\n    if (appPrivateKey !== undefined && appPrivateKey !== null) {\n        if (transitPublicKey !== undefined && transitPublicKey !== null) {\n            privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n            if (coreToken !== undefined && coreToken !== null) {\n                coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n            }\n        }\n        additionalProperties = {\n            email: (metadata === null || metadata === void 0 ? void 0 : metadata.email) ? metadata.email : null,\n            profile_url: (metadata === null || metadata === void 0 ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,\n            hubUrl,\n            blockstackAPIUrl,\n            associationToken,\n            version: VERSION,\n        };\n    }\n    else {\n    }\n    const payload = Object.assign({}, {\n        jti: makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: makeDIDFromAddress(address),\n        private_key: privateKeyPayload,\n        public_keys: [publicKey],\n        profile,\n        username,\n        core_token: coreTokenPayload,\n    }, additionalProperties);\n    const tokenSigner = new TokenSigner('ES256k', privateKey);\n    return tokenSigner.sign(payload);\n}\n//# sourceMappingURL=messages.js.map"]},"metadata":{},"sourceType":"module"}