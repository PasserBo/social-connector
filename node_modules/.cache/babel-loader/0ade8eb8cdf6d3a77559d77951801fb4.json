{"ast":null,"code":"import { Buffer, fetchPrivate, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { createStacksPrivateKey, createStacksPublicKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? StacksNetwork.fromNameOrNetwork(network).getAccountApiUrl(address) : defaultNetwork.getAccountApiUrl(address);\n  const response = await fetchPrivate(url);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n  const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(Object.assign({\n      transaction_payload: serializePayload(transactionPayload).toString('hex')\n    }, estimatedLen ? {\n      estimated_len: estimatedLen\n    } : {}))\n  };\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? StacksNetwork.fromNameOrNetwork(network).getTransactionFeeEstimateApiUrl() : defaultNetwork.getTransactionFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const data = await response.json();\n  return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n  const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: rawTx.toString('hex'),\n      attachment: attachment.toString('hex')\n    }) : rawTx\n  };\n  const response = await fetchPrivate(url, options);\n\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n\n  if (!isValidTxId) {\n    throw new Error(text);\n  }\n\n  return {\n    txid\n  };\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const url = StacksNetwork.fromNameOrNetwork(network).getAbiApiUrl(address, contractName);\n  const response = await fetchPrivate(url, options);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return JSON.parse(await response.text());\n}\n\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = transaction.serialize().byteLength;\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n  const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions = Object.assign(Object.assign({}, txOptions), {\n    publicKey\n  });\n  const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n  let authorization = null;\n  const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = transaction.serialize().byteLength;\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n  const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n\n  if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n    let abi;\n\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options === null || options === void 0 ? void 0 : options.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = transaction.serialize().byteLength;\n    const txFee = await estimateTransaction(payload, estimatedLen, network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    senderAddress\n  } = options;\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await fetchPrivate(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = options.transaction.serialize().byteLength;\n\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;\n        } catch (e) {\n          throw e;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return signer.transaction;\n}","map":{"version":3,"sources":["../../src/builders.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, fetchPrivate, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth, } from './authorization';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { createStacksPrivateKey, createStacksPublicKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyToAddress, publicKeyToString, } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload, } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition, } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal, } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n    const defaultNetwork = new StacksMainnet(); \n    const url = network\n        ? StacksNetwork.fromNameOrNetwork(network).getAccountApiUrl(address)\n        : defaultNetwork.getAccountApiUrl(address);\n    const response = await fetchPrivate(url);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const responseText = await response.text();\n    const result = JSON.parse(responseText);\n    return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n        throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n    const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = BigInt(transaction.serialize().byteLength);\n    const feeRate = BigInt(feeRateResult);\n    return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n    const options = {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(Object.assign({ transaction_payload: serializePayload(transactionPayload).toString('hex') }, (estimatedLen ? { estimated_len: estimatedLen } : {}))),\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? StacksNetwork.fromNameOrNetwork(network).getTransactionFeeEstimateApiUrl()\n        : defaultNetwork.getTransactionFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const data = await response.json();\n    return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n    const rawTx = transaction.serialize();\n    const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n    const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getBroadcastApiUrl();\n    return broadcastRawTransaction(rawTx, url, attachment);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n    const options = {\n        method: 'POST',\n        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n        body: attachment\n            ? JSON.stringify({\n                tx: rawTx.toString('hex'),\n                attachment: attachment.toString('hex'),\n            })\n            : rawTx,\n    };\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        try {\n            return (await response.json());\n        }\n        catch (e) {\n            throw Error(`Failed to broadcast transaction: ${e.message}`);\n        }\n    }\n    const text = await response.text();\n    const txid = text.replace(/[\"]+/g, '');\n    const isValidTxId = validateTxId(txid);\n    if (!isValidTxId) {\n        throw new Error(text);\n    }\n    return {\n        txid,\n    };\n}\nexport async function getAbi(address, contractName, network) {\n    const options = {\n        method: 'GET',\n    };\n    const url = StacksNetwork.fromNameOrNetwork(network).getAbiApiUrl(address, contractName);\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        const msg = await response.text().catch(() => '');\n        throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return JSON.parse(await response.text());\n}\nfunction deriveNetwork(transaction) {\n    switch (transaction.version) {\n        case TransactionVersion.Mainnet:\n            return new StacksMainnet();\n        case TransactionVersion.Testnet:\n            return new StacksTestnet();\n    }\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        memo: '',\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n    let authorization = null;\n    let spendingCondition = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = createSponsoredAuth(spendingCondition);\n    }\n    else {\n        authorization = createStandardAuth(spendingCondition);\n    }\n    const network = StacksNetwork.fromNameOrNetwork(options.network);\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const estimatedLen = transaction.serialize().byteLength;\n        const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n        transaction.setFee(txFee[1].fee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedSTXTokenTransfer(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport async function estimateContractDeploy(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n        throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n    const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        const msg = await response.text().catch(() => '');\n        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const stacksPublicKey = getPublicKey(privKey);\n    const publicKey = publicKeyToString(stacksPublicKey);\n    const unsignedTxOptions = Object.assign(Object.assign({}, txOptions), { publicKey });\n    const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n    if (txOptions.senderKey) {\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n    }\n    return transaction;\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createSmartContractPayload(options.contractName, options.codeBody);\n    const addressHashMode = AddressHashMode.SerializeP2PKH;\n    const pubKey = createStacksPublicKey(options.publicKey);\n    let authorization = null;\n    const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n    if (options.sponsored) {\n        authorization = createSponsoredAuth(spendingCondition);\n    }\n    else {\n        authorization = createStandardAuth(spendingCondition);\n    }\n    const network = StacksNetwork.fromNameOrNetwork(options.network);\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const estimatedLen = transaction.serialize().byteLength;\n        const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n        transaction.setFee(txFee[1].fee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n        throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const derivedNetwork = network !== null && network !== void 0 ? network : deriveNetwork(transaction);\n    const url = StacksNetwork.fromNameOrNetwork(derivedNetwork).getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        const msg = await response.text().catch(() => '');\n        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n    if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n        let abi;\n        if (typeof options.validateWithAbi === 'boolean') {\n            if (options === null || options === void 0 ? void 0 : options.network) {\n                abi = await getAbi(options.contractAddress, options.contractName, options.network);\n            }\n            else {\n                throw new Error('Network option must be provided in order to validate with ABI');\n            }\n        }\n        else {\n            abi = options.validateWithAbi;\n        }\n        validateContractCall(payload, abi);\n    }\n    let spendingCondition = null;\n    let authorization = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = createSponsoredAuth(spendingCondition);\n    }\n    else {\n        authorization = createStandardAuth(spendingCondition);\n    }\n    const network = StacksNetwork.fromNameOrNetwork(options.network);\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const estimatedLen = transaction.serialize().byteLength;\n        const txFee = await estimateTransaction(payload, estimatedLen, network);\n        transaction.setFee(txFee[1].fee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeContractCall(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedContractCall(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedContractCall(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n    return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n    return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n    const defaultOptions = {\n        network: new StacksMainnet(),\n    };\n    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n    const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n    const network = StacksNetwork.fromNameOrNetwork(options.network);\n    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n    const args = functionArgs.map(arg => cvToHex(arg));\n    const body = JSON.stringify({\n        sender: senderAddress,\n        arguments: args,\n    });\n    const response = await fetchPrivate(url, {\n        method: 'POST',\n        body,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    if (!response.ok) {\n        const msg = await response.text().catch(() => '');\n        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n    const defaultOptions = {\n        fee: 0,\n        sponsorNonce: 0,\n        sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n        network: sponsorOptions.transaction.version === TransactionVersion.Mainnet\n            ? new StacksMainnet()\n            : new StacksTestnet(),\n    };\n    const options = Object.assign(defaultOptions, sponsorOptions);\n    const network = StacksNetwork.fromNameOrNetwork(options.network);\n    const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n        let txFee = 0;\n        switch (options.transaction.payload.payloadType) {\n            case PayloadType.TokenTransfer:\n            case PayloadType.SmartContract:\n            case PayloadType.ContractCall:\n                const estimatedLen = options.transaction.serialize().byteLength;\n                try {\n                    txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n                        .fee;\n                }\n                catch (e) {\n                    throw e;\n                }\n                break;\n            default:\n                throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n        }\n        options.transaction.setFee(txFee);\n        options.fee = txFee;\n    }\n    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n        const addressVersion = network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n        const sponsorNonce = await getNonce(senderAddress, network);\n        options.sponsorNonce = sponsorNonce;\n    }\n    const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n    options.transaction.setSponsor(sponsorSpendingCondition);\n    const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n    const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n    signer.signSponsor(privKey);\n    return signer.transaction;\n}\n//# sourceMappingURL=builders.js.map"]},"metadata":{},"sourceType":"module"}