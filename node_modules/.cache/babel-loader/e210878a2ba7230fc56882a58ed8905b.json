{"ast":null,"code":"import _inherits from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey } from './keys';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\n\nvar Deserializable = /*#__PURE__*/function () {\n  function Deserializable() {\n    _classCallCheck(this, Deserializable);\n  }\n\n  _createClass(Deserializable, null, [{\n    key: \"deserialize\",\n    value: function deserialize(bufferReader) {\n      var message = new this();\n      message.deserialize(bufferReader);\n      return message;\n    }\n  }]);\n\n  return Deserializable;\n}();\n\nexport function createMessageSignature(signature) {\n  var length = Buffer.from(signature, 'hex').byteLength;\n\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature\n  };\n}\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')\n  };\n}\nexport function serializeMessageSignature(messageSignature) {\n  var bufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\n\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding: pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents: contents\n  };\n}\nexport function serializeTransactionAuthField(field) {\n  var bufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n\n      break;\n\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n  var authFieldType = bufferReader.readUInt8Enum(AuthFieldType, function (n) {\n    throw new DeserializationError(\"Could not read \".concat(n, \" as AuthFieldType\"));\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n\n    default:\n      throw new Error(\"Unknown auth field type: \".concat(JSON.stringify(authFieldType)));\n  }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  var signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  var keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding: keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  var stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  var signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition) {\n  var cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return Object.assign(Object.assign({}, cloned), {\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  });\n}\n\nexport function serializeSingleSigSpendingCondition(condition) {\n  var bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  var bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  var fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n  var numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n  var signer = bufferReader.readBuffer(20).toString('hex');\n  var nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  var fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  var keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, function (n) {\n    throw new DeserializationError(\"Could not parse \".concat(n, \" as PubKeyEncoding\"));\n  });\n  var signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: nonce,\n    fee: fee,\n    keyEncoding: keyEncoding,\n    signature: signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n  var signer = bufferReader.readBuffer(20).toString('hex');\n  var nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  var fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  var fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField).values;\n  var signaturesRequired = bufferReader.readUInt16BE();\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: nonce,\n    fee: fee,\n    fields: fields,\n    signaturesRequired: signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n  var hashMode = bufferReader.readUInt8Enum(AddressHashMode, function (n) {\n    throw new DeserializationError(\"Could not parse \".concat(n, \" as AddressHashMode\"));\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  var hashLength = 32 + 1 + 8 + 8;\n  var sigHash = curSigHash + Buffer.from([authType]).toString('hex') + intToBytes(fee, false, 8).toString('hex') + intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  var hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  var pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  var sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  var sigHashBuffer = Buffer.from(sigHash, 'hex');\n\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  var sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  var signature = signWithKey(privateKey, sigHashPreSign);\n  var publicKey = getPublicKey(privateKey);\n  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash: nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  var sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  var publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash: nextSigHash\n  };\n}\n\nfunction newInitialSigHash() {\n  var spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return '';\n  }\n}\n\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  var _nextVerification = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature),\n      nextSigHash = _nextVerification.nextSigHash;\n\n  return nextSigHash;\n}\n\nexport var Authorization = /*#__PURE__*/function (_Deserializable) {\n  _inherits(Authorization, _Deserializable);\n\n  var _super = _createSuper(Authorization);\n\n  function Authorization(authType, spendingConditions, sponsorSpendingCondition) {\n    var _this;\n\n    _classCallCheck(this, Authorization);\n\n    _this = _super.call(this);\n    _this.authType = authType;\n\n    if (spendingConditions) {\n      _this.spendingCondition = Object.assign(Object.assign({}, spendingConditions), {\n        nonce: intToBigInt(spendingConditions.nonce, false),\n        fee: intToBigInt(spendingConditions.fee, false)\n      });\n    }\n\n    if (sponsorSpendingCondition) {\n      _this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n        nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n        fee: intToBigInt(sponsorSpendingCondition.fee, false)\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(Authorization, [{\n    key: \"intoInitialSighashAuth\",\n    value: function intoInitialSighashAuth() {\n      if (this.spendingCondition) {\n        switch (this.authType) {\n          case AuthType.Standard:\n            return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n\n          case AuthType.Sponsored:\n            return new Authorization(AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());\n\n          default:\n            throw new SigningError('Unexpected authorization type for signing');\n        }\n      }\n\n      throw new Error('Authorization missing SpendingCondition');\n    }\n  }, {\n    key: \"setFee\",\n    value: function setFee(amount) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          this.spendingCondition.fee = intToBigInt(amount, false);\n          break;\n\n        case AuthType.Sponsored:\n          this.sponsorSpendingCondition.fee = intToBigInt(amount, false);\n          break;\n      }\n    }\n  }, {\n    key: \"getFee\",\n    value: function getFee() {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return this.spendingCondition.fee;\n\n        case AuthType.Sponsored:\n          return this.sponsorSpendingCondition.fee;\n\n        default:\n          return BigInt(0);\n      }\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      this.spendingCondition.nonce = intToBigInt(nonce, false);\n    }\n  }, {\n    key: \"setSponsorNonce\",\n    value: function setSponsorNonce(nonce) {\n      this.sponsorSpendingCondition.nonce = intToBigInt(nonce, false);\n    }\n  }, {\n    key: \"setSponsor\",\n    value: function setSponsor(sponsorSpendingCondition) {\n      this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n        nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n        fee: intToBigInt(sponsorSpendingCondition.fee, false)\n      });\n    }\n  }, {\n    key: \"verifyOrigin\",\n    value: function verifyOrigin(initialSigHash) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n\n        case AuthType.Sponsored:\n          return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n\n        default:\n          throw new SigningError('Invalid origin auth type');\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var bufferArray = new BufferArray();\n\n      if (this.authType === undefined) {\n        throw new SerializationError('\"authType\" is undefined');\n      }\n\n      bufferArray.appendByte(this.authType);\n\n      switch (this.authType) {\n        case AuthType.Standard:\n          if (this.spendingCondition === undefined) {\n            throw new SerializationError('\"spendingCondition\" is undefined');\n          }\n\n          bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n          break;\n\n        case AuthType.Sponsored:\n          if (this.spendingCondition === undefined) {\n            throw new SerializationError('\"spendingCondition\" is undefined');\n          }\n\n          if (this.sponsorSpendingCondition === undefined) {\n            throw new SerializationError('\"spendingCondition\" is undefined');\n          }\n\n          bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n          bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n          break;\n\n        default:\n          throw new SerializationError(\"Unexpected transaction AuthType while serializing: \".concat(JSON.stringify(this.authType)));\n      }\n\n      return bufferArray.concatBuffer();\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(bufferReader) {\n      this.authType = bufferReader.readUInt8Enum(AuthType, function (n) {\n        throw new DeserializationError(\"Could not parse \".concat(n, \" as AuthType\"));\n      });\n\n      switch (this.authType) {\n        case AuthType.Standard:\n          this.spendingCondition = deserializeSpendingCondition(bufferReader);\n          break;\n\n        case AuthType.Sponsored:\n          this.spendingCondition = deserializeSpendingCondition(bufferReader);\n          this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n          break;\n\n        default:\n          throw new DeserializationError(\"Unexpected transaction AuthType while deserializing: \".concat(JSON.stringify(this.authType)));\n      }\n    }\n  }]);\n\n  return Authorization;\n}(Deserializable);\nexport var StandardAuthorization = /*#__PURE__*/function (_Authorization) {\n  _inherits(StandardAuthorization, _Authorization);\n\n  var _super2 = _createSuper(StandardAuthorization);\n\n  function StandardAuthorization(spendingCondition) {\n    _classCallCheck(this, StandardAuthorization);\n\n    return _super2.call(this, AuthType.Standard, spendingCondition);\n  }\n\n  return _createClass(StandardAuthorization);\n}(Authorization);\nexport var SponsoredAuthorization = /*#__PURE__*/function (_Authorization2) {\n  _inherits(SponsoredAuthorization, _Authorization2);\n\n  var _super3 = _createSuper(SponsoredAuthorization);\n\n  function SponsoredAuthorization(originSpendingCondition, sponsorSpendingCondition) {\n    _classCallCheck(this, SponsoredAuthorization);\n\n    var sponsorSC = sponsorSpendingCondition;\n\n    if (!sponsorSC) {\n      sponsorSC = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0);\n    }\n\n    return _super3.call(this, AuthType.Sponsored, originSpendingCondition, sponsorSC);\n  }\n\n  return _createClass(SponsoredAuthorization);\n}(Authorization);","map":{"version":3,"sources":["../../src/authorization.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList, } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey, } from './keys';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\nclass Deserializable {\n    static deserialize(bufferReader) {\n        const message = new this();\n        message.deserialize(bufferReader);\n        return message;\n    }\n}\nexport function createMessageSignature(signature) {\n    const length = Buffer.from(signature, 'hex').byteLength;\n    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n        throw Error('Invalid signature');\n    }\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: signature,\n    };\n}\nexport function emptyMessageSignature() {\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n    };\n}\nexport function serializeMessageSignature(messageSignature) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(messageSignature.data);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n    return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n(function (AuthFieldType) {\n    AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n    AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n    return {\n        pubKeyEncoding,\n        type: StacksMessageType.TransactionAuthField,\n        contents,\n    };\n}\nexport function serializeTransactionAuthField(field) {\n    const bufferArray = new BufferArray();\n    switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n                bufferArray.push(serializePublicKey(field.contents));\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n                bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n            }\n            break;\n        case StacksMessageType.MessageSignature:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n            }\n            bufferArray.push(serializeMessageSignature(field.contents));\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n        throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n    });\n    switch (authFieldType) {\n        case AuthFieldType.PublicKeyCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.PublicKeyUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.SignatureCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n        case AuthFieldType.SignatureUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n        default:\n            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n    }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n    const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n    const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        keyEncoding,\n        signature: emptyMessageSignature(),\n    };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n    const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n    const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        fields: [],\n        signaturesRequired: numSigs,\n    };\n}\nexport function isSingleSig(condition) {\n    return 'signature' in condition;\n}\nfunction clearCondition(condition) {\n    const cloned = cloneDeep(condition);\n    cloned.nonce = 0;\n    cloned.fee = 0;\n    if (isSingleSig(cloned)) {\n        cloned.signature = emptyMessageSignature();\n    }\n    else {\n        cloned.fields = [];\n    }\n    return Object.assign(Object.assign({}, cloned), { nonce: BigInt(0), fee: BigInt(0) });\n}\nexport function serializeSingleSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    bufferArray.appendByte(condition.keyEncoding);\n    bufferArray.push(serializeMessageSignature(condition.signature));\n    return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    const fields = createLPList(condition.fields);\n    bufferArray.push(serializeLPList(fields));\n    const numSigs = Buffer.alloc(2);\n    numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n    bufferArray.push(numSigs);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n        throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n    });\n    const signature = deserializeMessageSignature(bufferReader);\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        keyEncoding,\n        signature,\n    };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n        .values;\n    const signaturesRequired = bufferReader.readUInt16BE();\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        fields,\n        signaturesRequired,\n    };\n}\nexport function serializeSpendingCondition(condition) {\n    if (isSingleSig(condition)) {\n        return serializeSingleSigSpendingCondition(condition);\n    }\n    else {\n        return serializeMultiSigSpendingCondition(condition);\n    }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n    const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n        throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n    });\n    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n        return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n    }\n    else {\n        return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n    }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n    const hashLength = 32 + 1 + 8 + 8;\n    const sigHash = curSigHash +\n        Buffer.from([authType]).toString('hex') +\n        intToBytes(fee, false, 8).toString('hex') +\n        intToBytes(nonce, false, 8).toString('hex');\n    if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(Buffer.from(sigHash, 'hex'));\n}\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n    const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n    const pubKeyEncoding = isCompressed(pubKey)\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n    const sigHashBuffer = Buffer.from(sigHash, 'hex');\n    if (sigHashBuffer.byteLength > hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(sigHashBuffer);\n}\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n    const signature = signWithKey(privateKey, sigHashPreSign);\n    const publicKey = getPublicKey(privateKey);\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        nextSig: signature,\n        nextSigHash,\n    };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n    const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        pubKey: publicKey,\n        nextSigHash,\n    };\n}\nfunction newInitialSigHash() {\n    const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n    spendingCondition.signer = createEmptyAddress().hash160;\n    spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n    spendingCondition.signature = emptyMessageSignature();\n    return spendingCondition;\n}\nfunction verify(condition, initialSigHash, authType) {\n    if (isSingleSig(condition)) {\n        return verifySingleSig(condition, initialSigHash, authType);\n    }\n    else {\n        return '';\n    }\n}\nfunction verifySingleSig(condition, initialSigHash, authType) {\n    const { nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n    return nextSigHash;\n}\nexport class Authorization extends Deserializable {\n    constructor(authType, spendingConditions, sponsorSpendingCondition) {\n        super();\n        this.authType = authType;\n        if (spendingConditions) {\n            this.spendingCondition = Object.assign(Object.assign({}, spendingConditions), { nonce: intToBigInt(spendingConditions.nonce, false), fee: intToBigInt(spendingConditions.fee, false) });\n        }\n        if (sponsorSpendingCondition) {\n            this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: intToBigInt(sponsorSpendingCondition.nonce, false), fee: intToBigInt(sponsorSpendingCondition.fee, false) });\n        }\n    }\n    intoInitialSighashAuth() {\n        if (this.spendingCondition) {\n            switch (this.authType) {\n                case AuthType.Standard:\n                    return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n                case AuthType.Sponsored:\n                    return new Authorization(AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());\n                default:\n                    throw new SigningError('Unexpected authorization type for signing');\n            }\n        }\n        throw new Error('Authorization missing SpendingCondition');\n    }\n    setFee(amount) {\n        switch (this.authType) {\n            case AuthType.Standard:\n                this.spendingCondition.fee = intToBigInt(amount, false);\n                break;\n            case AuthType.Sponsored:\n                this.sponsorSpendingCondition.fee = intToBigInt(amount, false);\n                break;\n        }\n    }\n    getFee() {\n        switch (this.authType) {\n            case AuthType.Standard:\n                return this.spendingCondition.fee;\n            case AuthType.Sponsored:\n                return this.sponsorSpendingCondition.fee;\n            default:\n                return BigInt(0);\n        }\n    }\n    setNonce(nonce) {\n        this.spendingCondition.nonce = intToBigInt(nonce, false);\n    }\n    setSponsorNonce(nonce) {\n        this.sponsorSpendingCondition.nonce = intToBigInt(nonce, false);\n    }\n    setSponsor(sponsorSpendingCondition) {\n        this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: intToBigInt(sponsorSpendingCondition.nonce, false), fee: intToBigInt(sponsorSpendingCondition.fee, false) });\n    }\n    verifyOrigin(initialSigHash) {\n        switch (this.authType) {\n            case AuthType.Standard:\n                return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n            case AuthType.Sponsored:\n                return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n            default:\n                throw new SigningError('Invalid origin auth type');\n        }\n    }\n    serialize() {\n        const bufferArray = new BufferArray();\n        if (this.authType === undefined) {\n            throw new SerializationError('\"authType\" is undefined');\n        }\n        bufferArray.appendByte(this.authType);\n        switch (this.authType) {\n            case AuthType.Standard:\n                if (this.spendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n                break;\n            case AuthType.Sponsored:\n                if (this.spendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                if (this.sponsorSpendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n                bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n                break;\n            default:\n                throw new SerializationError(`Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`);\n        }\n        return bufferArray.concatBuffer();\n    }\n    deserialize(bufferReader) {\n        this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n            throw new DeserializationError(`Could not parse ${n} as AuthType`);\n        });\n        switch (this.authType) {\n            case AuthType.Standard:\n                this.spendingCondition = deserializeSpendingCondition(bufferReader);\n                break;\n            case AuthType.Sponsored:\n                this.spendingCondition = deserializeSpendingCondition(bufferReader);\n                this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n                break;\n            default:\n                throw new DeserializationError(`Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`);\n        }\n    }\n}\nexport class StandardAuthorization extends Authorization {\n    constructor(spendingCondition) {\n        super(AuthType.Standard, spendingCondition);\n    }\n}\nexport class SponsoredAuthorization extends Authorization {\n    constructor(originSpendingCondition, sponsorSpendingCondition) {\n        let sponsorSC = sponsorSpendingCondition;\n        if (!sponsorSC) {\n            sponsorSC = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0);\n        }\n        super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n    }\n}\n//# sourceMappingURL=authorization.js.map"]},"metadata":{},"sourceType":"module"}