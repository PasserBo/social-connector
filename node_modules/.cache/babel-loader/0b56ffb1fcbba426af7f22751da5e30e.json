{"ast":null,"code":"import _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Buffer, intToBigInt } from '@stacks/common';\nimport { AnchorMode, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { Authorization, createMessageSignature, createTransactionAuthField, isSingleSig, nextSignature } from './authorization';\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, SigningError } from './errors';\nexport var StacksTransaction = /*#__PURE__*/function () {\n  function StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    _classCallCheck(this, StacksTransaction);\n\n    this.version = version;\n    this.auth = auth;\n\n    if ('amount' in payload) {\n      this.payload = Object.assign(Object.assign({}, payload), {\n        amount: intToBigInt(payload.amount, false)\n      });\n    } else {\n      this.payload = payload;\n    }\n\n    this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n    this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n\n  _createClass(StacksTransaction, [{\n    key: \"signBegin\",\n    value: function signBegin() {\n      var tx = cloneDeep(this);\n      tx.auth = tx.auth.intoInitialSighashAuth();\n      return tx.txid();\n    }\n  }, {\n    key: \"verifyBegin\",\n    value: function verifyBegin() {\n      var tx = cloneDeep(this);\n      tx.auth = tx.auth.intoInitialSighashAuth();\n      return tx.txid();\n    }\n  }, {\n    key: \"createTxWithSignature\",\n    value: function createTxWithSignature(signature) {\n      var parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n      var tx = cloneDeep(this);\n\n      if (!tx.auth.spendingCondition) {\n        throw new Error('Cannot set signature on transaction without spending condition');\n      }\n\n      tx.auth.spendingCondition.signature = createMessageSignature(parsedSig);\n      return tx;\n    }\n  }, {\n    key: \"verifyOrigin\",\n    value: function verifyOrigin() {\n      return this.auth.verifyOrigin(this.verifyBegin());\n    }\n  }, {\n    key: \"signNextOrigin\",\n    value: function signNextOrigin(sigHash, privateKey) {\n      if (this.auth.spendingCondition === undefined) {\n        throw new Error('\"auth.spendingCondition\" is undefined');\n      }\n\n      if (this.auth.authType === undefined) {\n        throw new Error('\"auth.authType\" is undefined');\n      }\n\n      return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n    }\n  }, {\n    key: \"signNextSponsor\",\n    value: function signNextSponsor(sigHash, privateKey) {\n      if (this.auth.sponsorSpendingCondition === undefined) {\n        throw new Error('\"auth.spendingCondition\" is undefined');\n      }\n\n      if (this.auth.authType === undefined) {\n        throw new Error('\"auth.authType\" is undefined');\n      }\n\n      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    }\n  }, {\n    key: \"appendPubkey\",\n    value: function appendPubkey(publicKey) {\n      var cond = this.auth.spendingCondition;\n\n      if (cond && !isSingleSig(cond)) {\n        var compressed = isCompressed(publicKey);\n        cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n      } else {\n        throw new Error(\"Can't append public key to a singlesig condition\");\n      }\n    }\n  }, {\n    key: \"signAndAppend\",\n    value: function signAndAppend(condition, curSigHash, authType, privateKey) {\n      var _nextSignature = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey),\n          nextSig = _nextSignature.nextSig,\n          nextSigHash = _nextSignature.nextSigHash;\n\n      if (isSingleSig(condition)) {\n        condition.signature = nextSig;\n      } else {\n        var compressed = privateKey.data.toString('hex').endsWith('01');\n        condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n      }\n\n      return nextSigHash;\n    }\n  }, {\n    key: \"txid\",\n    value: function txid() {\n      var serialized = this.serialize();\n      return txidFromData(serialized);\n    }\n  }, {\n    key: \"setSponsor\",\n    value: function setSponsor(sponsorSpendingCondition) {\n      if (this.auth.authType != AuthType.Sponsored) {\n        throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n      }\n\n      this.auth.setSponsor(sponsorSpendingCondition);\n    }\n  }, {\n    key: \"setFee\",\n    value: function setFee(amount) {\n      this.auth.setFee(amount);\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      this.auth.setNonce(nonce);\n    }\n  }, {\n    key: \"setSponsorNonce\",\n    value: function setSponsorNonce(nonce) {\n      this.auth.setSponsorNonce(nonce);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      if (this.version === undefined) {\n        throw new SerializationError('\"version\" is undefined');\n      }\n\n      if (this.chainId === undefined) {\n        throw new SerializationError('\"chainId\" is undefined');\n      }\n\n      if (this.auth === undefined) {\n        throw new SerializationError('\"auth\" is undefined');\n      }\n\n      if (this.anchorMode === undefined) {\n        throw new SerializationError('\"anchorMode\" is undefined');\n      }\n\n      if (this.payload === undefined) {\n        throw new SerializationError('\"payload\" is undefined');\n      }\n\n      var bufferArray = new BufferArray();\n      bufferArray.appendByte(this.version);\n      var chainIdBuffer = Buffer.alloc(4);\n      chainIdBuffer.writeUInt32BE(this.chainId, 0);\n      bufferArray.push(chainIdBuffer);\n      bufferArray.push(this.auth.serialize());\n      bufferArray.appendByte(this.anchorMode);\n      bufferArray.appendByte(this.postConditionMode);\n      bufferArray.push(serializeLPList(this.postConditions));\n      bufferArray.push(serializePayload(this.payload));\n      return bufferArray.concatBuffer();\n    }\n  }]);\n\n  return StacksTransaction;\n}();\nexport function deserializeTransaction(data) {\n  var bufferReader;\n\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n\n  var version = bufferReader.readUInt8Enum(TransactionVersion, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as TransactionVersion\"));\n  });\n  var chainId = bufferReader.readUInt32BE();\n  var auth = Authorization.deserialize(bufferReader);\n  var anchorMode = bufferReader.readUInt8Enum(AnchorMode, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as AnchorMode\"));\n  });\n  var postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as PostConditionMode\"));\n  });\n  var postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  var payload = deserializePayload(bufferReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"sources":["../../src/transaction.ts"],"names":[],"mappings":";;AAAA,SAAS,MAAT,EAA8B,WAA9B,QAAiD,gBAAjD;AACA,SACE,UADF,EAEE,QAFF,EAIE,gBAJF,EAKE,WALF,EAME,iBANF,EAOE,cAPF,EAQE,iBARF,EASE,kBATF,QAUO,aAVP;AAYA,SACE,aADF,EAEE,sBAFF,EAGE,0BAHF,EAIE,WAJF,EAKE,aALF,QAQO,iBARP;AAUA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,YAAjC,QAAqD,SAArD;AAEA,SAAS,kBAAT,EAAoD,gBAApD,QAA4E,WAA5E;AAEA,SAAS,YAAT,EAAuB,iBAAvB,EAA8D,eAA9D,QAAqF,SAArF;AAEA,SAAS,YAAT,QAAgE,QAAhE;AAEA,SAAS,YAAT,QAA6B,gBAA7B;AAEA,SAAS,kBAAT,EAA6B,YAA7B,QAAiD,UAAjD;AAEA,WAAa,iBAAb;AASE,6BACE,OADF,EAEE,IAFF,EAGE,OAHF,EAIE,cAJF,EAKE,iBALF,EAME,UANF,EAOE,OAPF,EAOmB;AAAA;;AAEjB,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,IAAZ;;AACA,QAAI,YAAY,OAAhB,EAAyB;AACvB,WAAK,OAAL,GAAY,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACP,OADO,CAAA,EACA;AACV,QAAA,MAAM,EAAE,WAAW,CAAC,OAAO,CAAC,MAAT,EAAiB,KAAjB;AADT,OADA,CAAZ;AAID,KALD,MAKO;AACL,WAAK,OAAL,GAAe,OAAf;AACD;;AACD,SAAK,OAAL,GAAe,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,gBAA1B;AACA,SAAK,iBAAL,GAAyB,iBAAiB,KAAA,IAAjB,IAAA,iBAAiB,KAAA,KAAA,CAAjB,GAAA,iBAAA,GAAqB,iBAAiB,CAAC,IAAhE;AACA,SAAK,cAAL,GAAsB,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAA,cAAA,GAAkB,YAAY,CAAC,EAAD,CAApD;;AAEA,QAAI,UAAJ,EAAgB;AACd,WAAK,UAAL,GAAkB,UAAlB;AACD,KAFD,MAEO;AACL,cAAQ,OAAO,CAAC,WAAhB;AACE,aAAK,WAAW,CAAC,QAAjB;AACA,aAAK,WAAW,CAAC,gBAAjB;AAAmC;AACjC,iBAAK,UAAL,GAAkB,UAAU,CAAC,WAA7B;AACA;AACD;;AACD,aAAK,WAAW,CAAC,YAAjB;AACA,aAAK,WAAW,CAAC,aAAjB;AACA,aAAK,WAAW,CAAC,aAAjB;AAAgC;AAC9B,iBAAK,UAAL,GAAkB,UAAU,CAAC,GAA7B;AACA;AACD;AAXH;AAaD;AACF;;AAjDH;AAAA;AAAA,WAmDE,qBAAS;AACP,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;AACA,MAAA,EAAE,CAAC,IAAH,GAAU,EAAE,CAAC,IAAH,CAAQ,sBAAR,EAAV;AACA,aAAO,EAAE,CAAC,IAAH,EAAP;AACD;AAvDH;AAAA;AAAA,WAyDE,uBAAW;AACT,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;AACA,MAAA,EAAE,CAAC,IAAH,GAAU,EAAE,CAAC,IAAH,CAAQ,sBAAR,EAAV;AACA,aAAO,EAAE,CAAC,IAAH,EAAP;AACD;AA7DH;AAAA;AAAA,WA+DE,+BAAsB,SAAtB,EAAgD;AAC9C,UAAM,SAAS,GAAG,OAAO,SAAP,KAAqB,QAArB,GAAgC,SAAhC,GAA4C,SAAS,CAAC,QAAV,CAAmB,KAAnB,CAA9D;AACA,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;;AACA,UAAI,CAAC,EAAE,CAAC,IAAH,CAAQ,iBAAb,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACD;;AACA,MAAA,EAAE,CAAC,IAAH,CAAQ,iBAAR,CAAyD,SAAzD,GACC,sBAAsB,CAAC,SAAD,CADvB;AAED,aAAO,EAAP;AACD;AAxEH;AAAA;AAAA,WA0EE,wBAAY;AACV,aAAO,KAAK,IAAL,CAAU,YAAV,CAAuB,KAAK,WAAL,EAAvB,CAAP;AACD;AA5EH;AAAA;AAAA,WA8EE,wBAAe,OAAf,EAAgC,UAAhC,EAA4D;AAC1D,UAAI,KAAK,IAAL,CAAU,iBAAV,KAAgC,SAApC,EAA+C;AAC7C,cAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,UAAI,KAAK,IAAL,CAAU,QAAV,KAAuB,SAA3B,EAAsC;AACpC,cAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,aAAO,KAAK,aAAL,CAAmB,KAAK,IAAL,CAAU,iBAA7B,EAAgD,OAAhD,EAAyD,QAAQ,CAAC,QAAlE,EAA4E,UAA5E,CAAP;AACD;AAtFH;AAAA;AAAA,WAwFE,yBAAgB,OAAhB,EAAiC,UAAjC,EAA6D;AAC3D,UAAI,KAAK,IAAL,CAAU,wBAAV,KAAuC,SAA3C,EAAsD;AACpD,cAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,UAAI,KAAK,IAAL,CAAU,QAAV,KAAuB,SAA3B,EAAsC;AACpC,cAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,aAAO,KAAK,aAAL,CACL,KAAK,IAAL,CAAU,wBADL,EAEL,OAFK,EAGL,QAAQ,CAAC,SAHJ,EAIL,UAJK,CAAP;AAMD;AArGH;AAAA;AAAA,WAuGE,sBAAa,SAAb,EAAuC;AACrC,UAAM,IAAI,GAAG,KAAK,IAAL,CAAU,iBAAvB;;AACA,UAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAD,CAAxB,EAAgC;AAC9B,YAAM,UAAU,GAAG,YAAY,CAAC,SAAD,CAA/B;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CACE,0BAA0B,CACxB,UAAU,GAAG,cAAc,CAAC,UAAlB,GAA+B,cAAc,CAAC,YADhC,EAExB,SAFwB,CAD5B;AAMD,OARD,MAQO;AACL,cAAM,IAAI,KAAJ,oDAAN;AACD;AACF;AApHH;AAAA;AAAA,WAsHE,uBACE,SADF,EAEE,UAFF,EAGE,QAHF,EAIE,UAJF,EAI8B;AAE5B,2BAAiC,aAAa,CAC5C,UAD4C,EAE5C,QAF4C,EAG5C,SAAS,CAAC,GAHkC,EAI5C,SAAS,CAAC,KAJkC,EAK5C,UAL4C,CAA9C;AAAA,UAAQ,OAAR,kBAAQ,OAAR;AAAA,UAAiB,WAAjB,kBAAiB,WAAjB;;AAOA,UAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AAC1B,QAAA,SAAS,CAAC,SAAV,GAAsB,OAAtB;AACD,OAFD,MAEO;AACL,YAAM,UAAU,GAAG,UAAU,CAAC,IAAX,CAAgB,QAAhB,CAAyB,KAAzB,EAAgC,QAAhC,CAAyC,IAAzC,CAAnB;AACA,QAAA,SAAS,CAAC,MAAV,CAAiB,IAAjB,CACE,0BAA0B,CACxB,UAAU,GAAG,cAAc,CAAC,UAAlB,GAA+B,cAAc,CAAC,YADhC,EAExB,OAFwB,CAD5B;AAMD;;AAED,aAAO,WAAP;AACD;AAhJH;AAAA;AAAA,WAkJE,gBAAI;AACF,UAAM,UAAU,GAAG,KAAK,SAAL,EAAnB;AACA,aAAO,YAAY,CAAC,UAAD,CAAnB;AACD;AArJH;AAAA;AAAA,WAuJE,oBAAW,wBAAX,EAA0D;AACxD,UAAI,KAAK,IAAL,CAAU,QAAV,IAAsB,QAAQ,CAAC,SAAnC,EAA8C;AAC5C,cAAM,IAAI,YAAJ,CAAiB,iDAAjB,CAAN;AACD;;AAED,WAAK,IAAL,CAAU,UAAV,CAAqB,wBAArB;AACD;AA7JH;AAAA;AAAA,WAoKE,gBAAO,MAAP,EAA0B;AACxB,WAAK,IAAL,CAAU,MAAV,CAAiB,MAAjB;AACD;AAtKH;AAAA;AAAA,WA6KE,kBAAS,KAAT,EAA2B;AACzB,WAAK,IAAL,CAAU,QAAV,CAAmB,KAAnB;AACD;AA/KH;AAAA;AAAA,WAsLE,yBAAgB,KAAhB,EAAkC;AAChC,WAAK,IAAL,CAAU,eAAV,CAA0B,KAA1B;AACD;AAxLH;AAAA;AAAA,WA0LE,qBAAS;AACP,UAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,cAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AACD,UAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,cAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AACD,UAAI,KAAK,IAAL,KAAc,SAAlB,EAA6B;AAC3B,cAAM,IAAI,kBAAJ,CAAuB,qBAAvB,CAAN;AACD;;AACD,UAAI,KAAK,UAAL,KAAoB,SAAxB,EAAmC;AACjC,cAAM,IAAI,kBAAJ,CAAuB,2BAAvB,CAAN;AACD;;AACD,UAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,cAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AAED,UAAM,WAAW,GAAgB,IAAI,WAAJ,EAAjC;AAEA,MAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,OAA5B;AACA,UAAM,aAAa,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAtB;AACA,MAAA,aAAa,CAAC,aAAd,CAA4B,KAAK,OAAjC,EAA0C,CAA1C;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,aAAjB;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,KAAK,IAAL,CAAU,SAAV,EAAjB;AACA,MAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,UAA5B;AACA,MAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,iBAA5B;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,eAAe,CAAC,KAAK,cAAN,CAAhC;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,gBAAgB,CAAC,KAAK,OAAN,CAAjC;AAEA,aAAO,WAAW,CAAC,YAAZ,EAAP;AACD;AAxNH;;AAAA;AAAA;AA8NA,OAAM,SAAU,sBAAV,CAAiC,IAAjC,EAAqE;AACzE,MAAI,YAAJ;;AACA,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAd,EAAiB,WAAjB,OAAmC,IAAvC,EAA6C;AAC3C,MAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CAAjB,CAAf;AACD,KAFD,MAEO;AACL,MAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAjB,CAAf;AACD;AACF,GAND,MAMO,IAAI,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAJ,EAA2B;AAChC,IAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,IAAjB,CAAf;AACD,GAFM,MAEA;AACL,IAAA,YAAY,GAAG,IAAf;AACD;;AACD,MAAM,OAAO,GAAG,YAAY,CAAC,aAAb,CAA2B,kBAA3B,EAA+C,UAAA,CAAC,EAAG;AACjE,UAAM,IAAI,KAAJ,2BAA6B,CAA7B,4BAAN;AACD,GAFe,CAAhB;AAGA,MAAM,OAAO,GAAG,YAAY,CAAC,YAAb,EAAhB;AACA,MAAM,IAAI,GAAG,aAAa,CAAC,WAAd,CAA0B,YAA1B,CAAb;AACA,MAAM,UAAU,GAAG,YAAY,CAAC,aAAb,CAA2B,UAA3B,EAAuC,UAAA,CAAC,EAAG;AAC5D,UAAM,IAAI,KAAJ,2BAA6B,CAA7B,oBAAN;AACD,GAFkB,CAAnB;AAGA,MAAM,iBAAiB,GAAG,YAAY,CAAC,aAAb,CAA2B,iBAA3B,EAA8C,UAAA,CAAC,EAAG;AAC1E,UAAM,IAAI,KAAJ,2BAA6B,CAA7B,2BAAN;AACD,GAFyB,CAA1B;AAGA,MAAM,cAAc,GAAG,iBAAiB,CAAC,YAAD,EAAe,iBAAiB,CAAC,aAAjC,CAAxC;AACA,MAAM,OAAO,GAAG,kBAAkB,CAAC,YAAD,CAAlC;AAEA,SAAO,IAAI,iBAAJ,CACL,OADK,EAEL,IAFK,EAGL,OAHK,EAIL,cAJK,EAKL,iBALK,EAML,UANK,EAOL,OAPK,CAAP;AASD","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt } from '@stacks/common';\nimport { AnchorMode, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion, } from './constants';\nimport { Authorization, createMessageSignature, createTransactionAuthField, isSingleSig, nextSignature, } from './authorization';\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n        this.version = version;\n        this.auth = auth;\n        if ('amount' in payload) {\n            this.payload = Object.assign(Object.assign({}, payload), { amount: intToBigInt(payload.amount, false) });\n        }\n        else {\n            this.payload = payload;\n        }\n        this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n        this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n        this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n        if (anchorMode) {\n            this.anchorMode = anchorMode;\n        }\n        else {\n            switch (payload.payloadType) {\n                case PayloadType.Coinbase:\n                case PayloadType.PoisonMicroblock: {\n                    this.anchorMode = AnchorMode.OnChainOnly;\n                    break;\n                }\n                case PayloadType.ContractCall:\n                case PayloadType.SmartContract:\n                case PayloadType.TokenTransfer: {\n                    this.anchorMode = AnchorMode.Any;\n                    break;\n                }\n            }\n        }\n    }\n    signBegin() {\n        const tx = cloneDeep(this);\n        tx.auth = tx.auth.intoInitialSighashAuth();\n        return tx.txid();\n    }\n    verifyBegin() {\n        const tx = cloneDeep(this);\n        tx.auth = tx.auth.intoInitialSighashAuth();\n        return tx.txid();\n    }\n    createTxWithSignature(signature) {\n        const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n        const tx = cloneDeep(this);\n        if (!tx.auth.spendingCondition) {\n            throw new Error('Cannot set signature on transaction without spending condition');\n        }\n        tx.auth.spendingCondition.signature =\n            createMessageSignature(parsedSig);\n        return tx;\n    }\n    verifyOrigin() {\n        return this.auth.verifyOrigin(this.verifyBegin());\n    }\n    signNextOrigin(sigHash, privateKey) {\n        if (this.auth.spendingCondition === undefined) {\n            throw new Error('\"auth.spendingCondition\" is undefined');\n        }\n        if (this.auth.authType === undefined) {\n            throw new Error('\"auth.authType\" is undefined');\n        }\n        return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n    }\n    signNextSponsor(sigHash, privateKey) {\n        if (this.auth.sponsorSpendingCondition === undefined) {\n            throw new Error('\"auth.spendingCondition\" is undefined');\n        }\n        if (this.auth.authType === undefined) {\n            throw new Error('\"auth.authType\" is undefined');\n        }\n        return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    }\n    appendPubkey(publicKey) {\n        const cond = this.auth.spendingCondition;\n        if (cond && !isSingleSig(cond)) {\n            const compressed = isCompressed(publicKey);\n            cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n        }\n        else {\n            throw new Error(`Can't append public key to a singlesig condition`);\n        }\n    }\n    signAndAppend(condition, curSigHash, authType, privateKey) {\n        const { nextSig, nextSigHash } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n        if (isSingleSig(condition)) {\n            condition.signature = nextSig;\n        }\n        else {\n            const compressed = privateKey.data.toString('hex').endsWith('01');\n            condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n        }\n        return nextSigHash;\n    }\n    txid() {\n        const serialized = this.serialize();\n        return txidFromData(serialized);\n    }\n    setSponsor(sponsorSpendingCondition) {\n        if (this.auth.authType != AuthType.Sponsored) {\n            throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n        }\n        this.auth.setSponsor(sponsorSpendingCondition);\n    }\n    setFee(amount) {\n        this.auth.setFee(amount);\n    }\n    setNonce(nonce) {\n        this.auth.setNonce(nonce);\n    }\n    setSponsorNonce(nonce) {\n        this.auth.setSponsorNonce(nonce);\n    }\n    serialize() {\n        if (this.version === undefined) {\n            throw new SerializationError('\"version\" is undefined');\n        }\n        if (this.chainId === undefined) {\n            throw new SerializationError('\"chainId\" is undefined');\n        }\n        if (this.auth === undefined) {\n            throw new SerializationError('\"auth\" is undefined');\n        }\n        if (this.anchorMode === undefined) {\n            throw new SerializationError('\"anchorMode\" is undefined');\n        }\n        if (this.payload === undefined) {\n            throw new SerializationError('\"payload\" is undefined');\n        }\n        const bufferArray = new BufferArray();\n        bufferArray.appendByte(this.version);\n        const chainIdBuffer = Buffer.alloc(4);\n        chainIdBuffer.writeUInt32BE(this.chainId, 0);\n        bufferArray.push(chainIdBuffer);\n        bufferArray.push(this.auth.serialize());\n        bufferArray.appendByte(this.anchorMode);\n        bufferArray.appendByte(this.postConditionMode);\n        bufferArray.push(serializeLPList(this.postConditions));\n        bufferArray.push(serializePayload(this.payload));\n        return bufferArray.concatBuffer();\n    }\n}\nexport function deserializeTransaction(data) {\n    let bufferReader;\n    if (typeof data === 'string') {\n        if (data.slice(0, 2).toLowerCase() === '0x') {\n            bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n        }\n        else {\n            bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n        }\n    }\n    else if (Buffer.isBuffer(data)) {\n        bufferReader = new BufferReader(data);\n    }\n    else {\n        bufferReader = data;\n    }\n    const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n        throw new Error(`Could not parse ${n} as TransactionVersion`);\n    });\n    const chainId = bufferReader.readUInt32BE();\n    const auth = Authorization.deserialize(bufferReader);\n    const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n        throw new Error(`Could not parse ${n} as AnchorMode`);\n    });\n    const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n        throw new Error(`Could not parse ${n} as PostConditionMode`);\n    });\n    const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n    const payload = deserializePayload(bufferReader);\n    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"module"}