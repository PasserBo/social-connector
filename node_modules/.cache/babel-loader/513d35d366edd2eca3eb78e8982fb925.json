{"ast":null,"code":"import { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport class TransactionSigner {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n    const spendingCondition = transaction.auth.spendingCondition;\n\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(transaction, spendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n\n      if (this.checkOversign && spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete() {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n\n}","map":{"version":3,"sources":["../../src/signer.ts"],"names":[],"mappings":"AAGA,SAAS,WAAT,EAAsB,gBAAtB,QAAqE,iBAArE;AACA,SAAS,SAAT,QAA0B,SAA1B;AACA,SAAS,QAAT,EAAmB,cAAnB,EAAmC,iBAAnC,QAA4D,aAA5D;AACA,SAAS,YAAT,QAA6B,UAA7B;AAEA,OAAM,MAAO,iBAAP,CAAwB;AAO5B,EAAA,WAAA,CAAY,WAAZ,EAA0C;AACxC,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,OAAL,GAAe,WAAW,CAAC,SAAZ,EAAf;AACA,SAAK,UAAL,GAAkB,KAAlB;AACA,SAAK,aAAL,GAAqB,IAArB;AACA,SAAK,YAAL,GAAoB,IAApB;AAIA,UAAM,iBAAiB,GAAG,WAAW,CAAC,IAAZ,CAAiB,iBAA3C;;AACA,QAAI,iBAAiB,IAAI,CAAC,WAAW,CAAC,iBAAD,CAArC,EAA0D;AACxD,UACE,iBAAiB,CAAC,MAAlB,CAAyB,MAAzB,CACE,KAAK,IAAI,KAAK,CAAC,QAAN,CAAe,IAAf,KAAwB,iBAAiB,CAAC,gBADrD,EAEE,MAFF,IAEY,iBAAiB,CAAC,kBAHhC,EAIE;AACA,cAAM,IAAI,KAAJ,CAAU,yDAAV,CAAN;AACD;;AAED,MAAA,iBAAiB,CAAC,MAAlB,CAAyB,OAAzB,CAAiC,KAAK,IAAG;AACvC,YAAI,KAAK,CAAC,QAAN,CAAe,IAAf,KAAwB,iBAAiB,CAAC,gBAA9C,EAAgE;AAC9D,gBAAM,SAAS,GAAG,KAAK,CAAC,QAAxB;AACA,gBAAM,UAAU,GAAG,gBAAgB,CACjC,KAAK,OAD4B,EAEjC,WAAW,CAAC,IAAZ,CAAiB,QAFgB,EAGjC,iBAAiB,CAAC,GAHe,EAIjC,iBAAiB,CAAC,KAJe,EAKjC,cAAc,CAAC,UALkB,EAMjC,SANiC,CAAnC;AAQA,eAAK,OAAL,GAAe,UAAU,CAAC,WAA1B;AACD;AACF,OAbD;AAcD;AACF;;AAEyB,SAAnB,mBAAmB,CACxB,WADwB,EAExB,iBAFwB,EAEgB;AAExC,QAAI,WAAW,CAAC,IAAZ,CAAiB,QAAjB,IAA6B,QAAQ,CAAC,SAA1C,EAAqD;AACnD,YAAM,IAAI,YAAJ,CAAiB,iDAAjB,CAAN;AACD;;AAED,UAAM,EAAE,GAAsB,SAAS,CAAC,WAAD,CAAvC;AACA,IAAA,EAAE,CAAC,UAAH,CAAc,iBAAd;AACA,UAAM,aAAa,GAAG,EAAE,CAAC,YAAH,EAAtB;AACA,UAAM,MAAM,GAAG,IAAI,IAAJ,CAAS,EAAT,CAAf;AACA,IAAA,MAAM,CAAC,UAAP,GAAoB,IAApB;AACA,IAAA,MAAM,CAAC,OAAP,GAAiB,aAAjB;AACA,IAAA,MAAM,CAAC,aAAP,GAAuB,IAAvB;AACA,IAAA,MAAM,CAAC,YAAP,GAAsB,IAAtB;AACA,WAAO,MAAP;AACD;;AAED,EAAA,UAAU,CAAC,UAAD,EAA6B;AACrC,QAAI,KAAK,YAAL,IAAqB,KAAK,UAA9B,EAA0C;AACxC,YAAM,IAAI,YAAJ,CAAiB,sCAAjB,CAAN;AACD;;AAED,QAAI,KAAK,WAAL,CAAiB,IAAjB,KAA0B,SAA9B,EAAyC;AACvC,YAAM,IAAI,YAAJ,CAAiB,iCAAjB,CAAN;AACD;;AACD,QAAI,KAAK,WAAL,CAAiB,IAAjB,CAAsB,iBAAtB,KAA4C,SAAhD,EAA2D;AACzD,YAAM,IAAI,YAAJ,CAAiB,mDAAjB,CAAN;AACD;;AAED,QAAI,CAAC,WAAW,CAAC,KAAK,WAAL,CAAiB,IAAjB,CAAsB,iBAAvB,CAAhB,EAA2D;AACzD,YAAM,iBAAiB,GAAG,KAAK,WAAL,CAAiB,IAAjB,CAAsB,iBAAhD;;AACA,UACE,KAAK,aAAL,IACA,iBAAiB,CAAC,MAAlB,CAAyB,MAAzB,CACE,KAAK,IAAI,KAAK,CAAC,QAAN,CAAe,IAAf,KAAwB,iBAAiB,CAAC,gBADrD,EAEE,MAFF,IAEY,iBAAiB,CAAC,kBAJhC,EAKE;AACA,cAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;AAED,UAAM,WAAW,GAAG,KAAK,WAAL,CAAiB,cAAjB,CAAgC,KAAK,OAArC,EAA8C,UAA9C,CAApB;AACA,SAAK,OAAL,GAAe,WAAf;AACD;;AAED,EAAA,YAAY,CAAC,SAAD,EAA2B;AACrC,QAAI,KAAK,YAAL,IAAqB,KAAK,UAA9B,EAA0C;AACxC,YAAM,KAAK,CAAC,sDAAD,CAAX;AACD;;AAED,QAAI,KAAK,WAAL,CAAiB,IAAjB,KAA0B,SAA9B,EAAyC;AACvC,YAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,QAAI,KAAK,WAAL,CAAiB,IAAjB,CAAsB,iBAAtB,KAA4C,SAAhD,EAA2D;AACzD,YAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,SAAK,WAAL,CAAiB,YAAjB,CAA8B,SAA9B;AACD;;AAED,EAAA,WAAW,CAAC,UAAD,EAA6B;AACtC,QAAI,KAAK,WAAL,CAAiB,IAAjB,KAA0B,SAA9B,EAAyC;AACvC,YAAM,IAAI,YAAJ,CAAiB,iCAAjB,CAAN;AACD;;AACD,QAAI,KAAK,WAAL,CAAiB,IAAjB,CAAsB,QAAtB,KAAmC,QAAQ,CAAC,SAAhD,EAA2D;AACzD,YAAM,IAAI,YAAJ,CAAiB,uDAAjB,CAAN;AACD;;AAED,UAAM,WAAW,GAAG,KAAK,WAAL,CAAiB,eAAjB,CAAiC,KAAK,OAAtC,EAA+C,UAA/C,CAApB;AACA,SAAK,OAAL,GAAe,WAAf;AACA,SAAK,UAAL,GAAkB,IAAlB;AACD;;AAED,EAAA,eAAe,GAAA;AACb,WAAO,SAAS,CAAC,KAAK,WAAN,CAAhB;AACD;;AAED,EAAA,MAAM,CAAC,WAAD,EAA+B;AACnC,SAAK,WAAL,GAAmB,SAAS,CAAC,WAAD,CAA5B;AACA,SAAK,OAAL,GAAe,WAAW,CAAC,SAAZ,EAAf;AACD;;AA7H2B","sourceRoot":"","sourcesContent":["import { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport class TransactionSigner {\n    constructor(transaction) {\n        this.transaction = transaction;\n        this.sigHash = transaction.signBegin();\n        this.originDone = false;\n        this.checkOversign = true;\n        this.checkOverlap = true;\n        const spendingCondition = transaction.auth.spendingCondition;\n        if (spendingCondition && !isSingleSig(spendingCondition)) {\n            if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n                throw new Error('SpendingCondition has more signatures than are expected');\n            }\n            spendingCondition.fields.forEach(field => {\n                if (field.contents.type === StacksMessageType.MessageSignature) {\n                    const signature = field.contents;\n                    const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n                    this.sigHash = nextVerify.nextSigHash;\n                }\n            });\n        }\n    }\n    static createSponsorSigner(transaction, spendingCondition) {\n        if (transaction.auth.authType != AuthType.Sponsored) {\n            throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n        }\n        const tx = cloneDeep(transaction);\n        tx.setSponsor(spendingCondition);\n        const originSigHash = tx.verifyOrigin();\n        const signer = new this(tx);\n        signer.originDone = true;\n        signer.sigHash = originSigHash;\n        signer.checkOversign = true;\n        signer.checkOverlap = true;\n        return signer;\n    }\n    signOrigin(privateKey) {\n        if (this.checkOverlap && this.originDone) {\n            throw new SigningError('Cannot sign origin after sponsor key');\n        }\n        if (this.transaction.auth === undefined) {\n            throw new SigningError('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.spendingCondition === undefined) {\n            throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n        }\n        if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n            const spendingCondition = this.transaction.auth.spendingCondition;\n            if (this.checkOversign &&\n                spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n                throw new Error('Origin would have too many signatures');\n            }\n        }\n        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n        this.sigHash = nextSighash;\n    }\n    appendOrigin(publicKey) {\n        if (this.checkOverlap && this.originDone) {\n            throw Error('Cannot append public key to origin after sponsor key');\n        }\n        if (this.transaction.auth === undefined) {\n            throw new Error('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.spendingCondition === undefined) {\n            throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n        }\n        this.transaction.appendPubkey(publicKey);\n    }\n    signSponsor(privateKey) {\n        if (this.transaction.auth === undefined) {\n            throw new SigningError('\"transaction.auth\" is undefined');\n        }\n        if (this.transaction.auth.authType !== AuthType.Sponsored) {\n            throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n        }\n        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n        this.sigHash = nextSighash;\n        this.originDone = true;\n    }\n    getTxInComplete() {\n        return cloneDeep(this.transaction);\n    }\n    resume(transaction) {\n        this.transaction = cloneDeep(transaction);\n        this.sigHash = transaction.signBegin();\n    }\n}\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"module"}