{"ast":null,"code":"import { useMemo } from 'react';\n\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to ref \\\"\" + ref + \"\\\"\");\n    }\n  }\n}\n\nfunction useMergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return useMemo(function () {\n    if (refs.every(function (ref) {\n      return ref == null;\n    })) {\n      return null;\n    }\n\n    return function (node) {\n      refs.forEach(function (ref) {\n        if (ref) assignRef(ref, node);\n      });\n    };\n  }, refs);\n}\n\nexport { assignRef, useMergeRefs };","map":{"version":3,"sources":["../../src/hooks/use-merge-refs.ts"],"names":["assignRef","ref","value","useMergeRefs","refs"],"mappings":";;SAIgBA,S,CAAmBC,G,EAAkBC,K,EAAAA;AACnD,MAAID,GAAG,IAAP,IAAA,EAAiB;;AACjB,MAAI,OAAA,GAAA,KAAJ,UAAA,EAA+B;AAC7BA,IAAAA,GAAG,CAAHA,KAAG,CAAHA;AADF,GAAA,MAEO;AACL,QAAI;AACDA,MAAAA,GAAiC,CAAjCA,OAAAA,GAAAA,KAAAA;AADH,KAAA,CAEE,OAAA,KAAA,EAAc;AACd,YAAM,IAAA,KAAA,CAAA,2BAAA,KAAA,GAAA,cAAA,GAAA,GAAA,GAAN,IAAM,CAAN;AACD;AACF;AACF;;SAEeE,Y,GAAAA;oCAAmBC,IAAAA,GAAAA,IAAAA,KAAAA,CAAAA,IAAAA,C,EAAAA,IAAAA,GAAAA,C,EAAAA,IAAAA,GAAAA,I,EAAAA,IAAAA,E,EAAAA;AAAAA,IAAAA,IAAAA,CAAAA,IAAAA,CAAAA,GAAAA,SAAAA,CAAAA,IAAAA,CAAAA;;;AACjC,SAAO,OAAA,CAAc,YAAA;AACnB,QAAI,IAAI,CAAJ,KAAA,CAAW,UAAA,GAAA,EAAG;AAAA,aAAIH,GAAG,IAAP,IAAA;AAAlB,KAAI,CAAJ,EAAoC;AAClC,aAAA,IAAA;AACD;;AACD,WAAO,UAAA,IAAA,EAAA;AACLG,MAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,GAAA,EAAG;AACd,YAAA,GAAA,EAASJ,SAAS,CAAA,GAAA,EAATA,IAAS,CAATA;AADXI,OAAAA;AADF,KAAA;AAJK,GAAA,EAAP,IAAO,CAAP;AAUD","sourcesContent":["import * as React from 'react';\n\ntype ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>;\n\nexport function assignRef<T = any>(ref: ReactRef<T>, value: T) {\n  if (ref == null) return;\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    try {\n      (ref as React.MutableRefObject<T>).current = value;\n    } catch (error) {\n      throw new Error(`Cannot assign value \"${value}\" to ref \"${ref}\"`);\n    }\n  }\n}\n\nexport function useMergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return (node: T) => {\n      refs.forEach(ref => {\n        if (ref) assignRef(ref, node);\n      });\n    };\n  }, refs);\n}\n"]},"metadata":{},"sourceType":"module"}