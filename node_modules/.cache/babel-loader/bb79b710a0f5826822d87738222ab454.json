{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64url_1 = require(\"base64url\");\n\nvar cryptoClients_1 = require(\"./cryptoClients\");\n\nvar errors_1 = require(\"./errors\");\n\nvar sha256_1 = require(\"./cryptoClients/sha256\");\n\nfunction createSigningInput(payload, header) {\n  var tokenParts = []; // add in the header\n\n  var encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  var encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  var signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  var header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nvar TokenSigner = /*#__PURE__*/function () {\n  function TokenSigner(signingAlgorithm, rawPrivateKey) {\n    _classCallCheck(this, TokenSigner);\n\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  _createClass(TokenSigner, [{\n    key: \"header\",\n    value: function header() {\n      var _header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var defaultHeader = {\n        typ: this.tokenType,\n        alg: this.cryptoClient.algorithmName\n      };\n      return Object.assign({}, defaultHeader, _header);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // generate the token header\n      var header = this.header(customHeader); // prepare the message to be signed\n\n      var signingInput = createSigningInput(payload, header);\n      var signingInputHash = sha256_1.hashSha256(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n  }, {\n    key: \"signAsync\",\n    value: function signAsync(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var header, signingInput, signingInputHash;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // generate the token header\n                header = this.header(customHeader); // prepare the message to be signed\n\n                signingInput = createSigningInput(payload, header);\n                _context.next = 4;\n                return sha256_1.hashSha256Async(signingInput);\n\n              case 4:\n                signingInputHash = _context.sent;\n                return _context.abrupt(\"return\", this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"createWithSignedHash\",\n    value: function createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n      // sign the message and add in the signature\n      var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n      if (expanded) {\n        var signedToken = {\n          'header': [base64url_1.default.encode(JSON.stringify(header))],\n          'payload': JSON.stringify(payload),\n          'signature': [signature]\n        };\n        return signedToken;\n      } else {\n        return [signingInput, signature].join('.');\n      }\n    }\n  }]);\n\n  return TokenSigner;\n}();\n\nexports.TokenSigner = TokenSigner;","map":{"version":3,"sources":["signer.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = require(\"base64url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n    const tokenParts = [];\n    // add in the header\n    const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n    tokenParts.push(encodedHeader);\n    // add in the payload\n    const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n    tokenParts.push(encodedPayload);\n    // prepare the message\n    const signingInput = tokenParts.join('.');\n    // return the signing input\n    return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n    const header = { typ: 'JWT', alg: 'none' };\n    return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n    constructor(signingAlgorithm, rawPrivateKey) {\n        if (!(signingAlgorithm && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw new Error('signing algorithm parameter must be a string');\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw new Error('invalid signing algorithm');\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPrivateKey = rawPrivateKey;\n    }\n    header(header = {}) {\n        const defaultHeader = { typ: this.tokenType,\n            alg: this.cryptoClient.algorithmName };\n        return Object.assign({}, defaultHeader, header);\n    }\n    sign(payload, expanded = false, customHeader = {}) {\n        // generate the token header\n        const header = this.header(customHeader);\n        // prepare the message to be signed\n        const signingInput = createSigningInput(payload, header);\n        const signingInputHash = sha256_1.hashSha256(signingInput);\n        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n    signAsync(payload, expanded = false, customHeader = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // generate the token header\n            const header = this.header(customHeader);\n            // prepare the message to be signed\n            const signingInput = createSigningInput(payload, header);\n            const signingInputHash = yield sha256_1.hashSha256Async(signingInput);\n            return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n        });\n    }\n    createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n        // sign the message and add in the signature\n        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n        if (expanded) {\n            const signedToken = {\n                'header': [\n                    base64url_1.default.encode(JSON.stringify(header))\n                ],\n                'payload': JSON.stringify(payload),\n                'signature': [\n                    signature\n                ]\n            };\n            return signedToken;\n        }\n        else {\n            return [signingInput, signature].join('.');\n        }\n    }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}