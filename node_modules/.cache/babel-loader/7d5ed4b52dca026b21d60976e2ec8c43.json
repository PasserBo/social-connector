{"ast":null,"code":"import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey } from './keys';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nexport function createMessageSignature(signature) {\n  const length = Buffer.from(signature, 'hex').byteLength;\n\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature\n  };\n}\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')\n  };\n}\nexport function serializeMessageSignature(messageSignature) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\n\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents\n  };\n}\nexport function serializeTransactionAuthField(field) {\n  const bufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n\n      break;\n\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition) {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return Object.assign(Object.assign({}, cloned), {\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  });\n}\n\nexport function serializeSingleSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');\n  }\n\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField).values;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Failed to parse multisig spending condition: too many signatures');\n        break;\n    }\n  }\n\n  const signaturesRequired = bufferReader.readUInt16BE();\n  if (numSigs !== signaturesRequired) throw new VerificationError(`Incorrect number of signatures`);\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  const hashLength = 32 + 1 + 8 + 8;\n  const sigHash = curSigHash + Buffer.from([authType]).toString('hex') + intToBytes(fee, false, 8).toString('hex') + intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  const pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash\n  };\n}\n\nfunction newInitialSigHash() {\n  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  const {\n    pubKey,\n    nextSigHash\n  } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(condition, initialSigHash, authType) {\n  const publicKeys = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const {\n          pubKey,\n          nextSigHash\n        } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n        break;\n    }\n\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired) throw new VerificationError('Incorrect number of signatures');\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return curSigHash;\n}\n\nexport function createStandardAuth(spendingCondition) {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition\n  };\n}\nexport function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0)\n  };\n}\nexport function intoInitialSighashAuth(auth) {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\nexport function verifyOrigin(auth, initialSigHash) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\nexport function setFee(auth, amount) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), {\n        fee: intToBigInt(amount, false)\n      });\n      return Object.assign(Object.assign({}, auth), {\n        spendingCondition\n      });\n\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), {\n        fee: intToBigInt(amount, false)\n      });\n      return Object.assign(Object.assign({}, auth), {\n        sponsorSpendingCondition\n      });\n  }\n}\nexport function getFee(auth) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\nexport function setNonce(auth, nonce) {\n  const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), {\n    nonce: intToBigInt(nonce, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    spendingCondition\n  });\n}\nexport function setSponsorNonce(auth, nonce) {\n  const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), {\n    nonce: intToBigInt(nonce, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    sponsorSpendingCondition\n  });\n}\nexport function setSponsor(auth, sponsorSpendingCondition) {\n  const sc = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    sponsorSpendingCondition: sc\n  });\n}\nexport function serializeAuthorization(auth) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n\n    case AuthType.Sponsored:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAuthorization(bufferReader) {\n  const authType = bufferReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n  let spendingCondition;\n\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      return createStandardAuth(spendingCondition);\n\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}","map":{"version":3,"sources":["../../src/authorization.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList, } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey, } from './keys';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nexport function createMessageSignature(signature) {\n    const length = Buffer.from(signature, 'hex').byteLength;\n    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n        throw Error('Invalid signature');\n    }\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: signature,\n    };\n}\nexport function emptyMessageSignature() {\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n    };\n}\nexport function serializeMessageSignature(messageSignature) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(messageSignature.data);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n    return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n(function (AuthFieldType) {\n    AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n    AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n    return {\n        pubKeyEncoding,\n        type: StacksMessageType.TransactionAuthField,\n        contents,\n    };\n}\nexport function serializeTransactionAuthField(field) {\n    const bufferArray = new BufferArray();\n    switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n                bufferArray.push(serializePublicKey(field.contents));\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n                bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n            }\n            break;\n        case StacksMessageType.MessageSignature:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n            }\n            bufferArray.push(serializeMessageSignature(field.contents));\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n        throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n    });\n    switch (authFieldType) {\n        case AuthFieldType.PublicKeyCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.PublicKeyUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.SignatureCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n        case AuthFieldType.SignatureUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n        default:\n            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n    }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n    const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n    const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        keyEncoding,\n        signature: emptyMessageSignature(),\n    };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n    const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n    const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        fields: [],\n        signaturesRequired: numSigs,\n    };\n}\nexport function isSingleSig(condition) {\n    return 'signature' in condition;\n}\nfunction clearCondition(condition) {\n    const cloned = cloneDeep(condition);\n    cloned.nonce = 0;\n    cloned.fee = 0;\n    if (isSingleSig(cloned)) {\n        cloned.signature = emptyMessageSignature();\n    }\n    else {\n        cloned.fields = [];\n    }\n    return Object.assign(Object.assign({}, cloned), { nonce: BigInt(0), fee: BigInt(0) });\n}\nexport function serializeSingleSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    bufferArray.appendByte(condition.keyEncoding);\n    bufferArray.push(serializeMessageSignature(condition.signature));\n    return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    const fields = createLPList(condition.fields);\n    bufferArray.push(serializeLPList(fields));\n    const numSigs = Buffer.alloc(2);\n    numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n    bufferArray.push(numSigs);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n        throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n    });\n    if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n        throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');\n    }\n    const signature = deserializeMessageSignature(bufferReader);\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        keyEncoding,\n        signature,\n    };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n        .values;\n    let haveUncompressed = false;\n    let numSigs = 0;\n    for (const field of fields) {\n        switch (field.contents.type) {\n            case StacksMessageType.PublicKey:\n                if (!isCompressed(field.contents))\n                    haveUncompressed = true;\n                break;\n            case StacksMessageType.MessageSignature:\n                if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)\n                    haveUncompressed = true;\n                numSigs += 1;\n                if (numSigs === 65536)\n                    throw new VerificationError('Failed to parse multisig spending condition: too many signatures');\n                break;\n        }\n    }\n    const signaturesRequired = bufferReader.readUInt16BE();\n    if (numSigs !== signaturesRequired)\n        throw new VerificationError(`Incorrect number of signatures`);\n    if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\n        throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        fields,\n        signaturesRequired,\n    };\n}\nexport function serializeSpendingCondition(condition) {\n    if (isSingleSig(condition)) {\n        return serializeSingleSigSpendingCondition(condition);\n    }\n    else {\n        return serializeMultiSigSpendingCondition(condition);\n    }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n    const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n        throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n    });\n    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n        return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n    }\n    else {\n        return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n    }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n    const hashLength = 32 + 1 + 8 + 8;\n    const sigHash = curSigHash +\n        Buffer.from([authType]).toString('hex') +\n        intToBytes(fee, false, 8).toString('hex') +\n        intToBytes(nonce, false, 8).toString('hex');\n    if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(Buffer.from(sigHash, 'hex'));\n}\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n    const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n    const pubKeyEncoding = isCompressed(pubKey)\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n    const sigHashBuffer = Buffer.from(sigHash, 'hex');\n    if (sigHashBuffer.byteLength > hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(sigHashBuffer);\n}\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n    const signature = signWithKey(privateKey, sigHashPreSign);\n    const publicKey = getPublicKey(privateKey);\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        nextSig: signature,\n        nextSigHash,\n    };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n    const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        pubKey: publicKey,\n        nextSigHash,\n    };\n}\nfunction newInitialSigHash() {\n    const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n    spendingCondition.signer = createEmptyAddress().hash160;\n    spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n    spendingCondition.signature = emptyMessageSignature();\n    return spendingCondition;\n}\nfunction verify(condition, initialSigHash, authType) {\n    if (isSingleSig(condition)) {\n        return verifySingleSig(condition, initialSigHash, authType);\n    }\n    else {\n        return verifyMultiSig(condition, initialSigHash, authType);\n    }\n}\nfunction verifySingleSig(condition, initialSigHash, authType) {\n    const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n    const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n    if (addrBytes !== condition.signer)\n        throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n    return nextSigHash;\n}\nfunction verifyMultiSig(condition, initialSigHash, authType) {\n    const publicKeys = [];\n    let curSigHash = initialSigHash;\n    let haveUncompressed = false;\n    let numSigs = 0;\n    for (const field of condition.fields) {\n        let foundPubKey;\n        switch (field.contents.type) {\n            case StacksMessageType.PublicKey:\n                if (!isCompressed(field.contents))\n                    haveUncompressed = true;\n                foundPubKey = field.contents;\n                break;\n            case StacksMessageType.MessageSignature:\n                if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)\n                    haveUncompressed = true;\n                const { pubKey, nextSigHash } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);\n                curSigHash = nextSigHash;\n                foundPubKey = pubKey;\n                numSigs += 1;\n                if (numSigs === 65536)\n                    throw new VerificationError('Too many signatures');\n                break;\n        }\n        publicKeys.push(foundPubKey);\n    }\n    if (numSigs !== condition.signaturesRequired)\n        throw new VerificationError('Incorrect number of signatures');\n    if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\n        throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n    const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;\n    if (addrBytes !== condition.signer)\n        throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n    return curSigHash;\n}\nexport function createStandardAuth(spendingCondition) {\n    return {\n        authType: AuthType.Standard,\n        spendingCondition,\n    };\n}\nexport function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {\n    return {\n        authType: AuthType.Sponsored,\n        spendingCondition,\n        sponsorSpendingCondition: sponsorSpendingCondition\n            ? sponsorSpendingCondition\n            : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n    };\n}\nexport function intoInitialSighashAuth(auth) {\n    if (auth.spendingCondition) {\n        switch (auth.authType) {\n            case AuthType.Standard:\n                return createStandardAuth(clearCondition(auth.spendingCondition));\n            case AuthType.Sponsored:\n                return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n            default:\n                throw new SigningError('Unexpected authorization type for signing');\n        }\n    }\n    throw new Error('Authorization missing SpendingCondition');\n}\nexport function verifyOrigin(auth, initialSigHash) {\n    switch (auth.authType) {\n        case AuthType.Standard:\n            return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n        case AuthType.Sponsored:\n            return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n        default:\n            throw new SigningError('Invalid origin auth type');\n    }\n}\nexport function setFee(auth, amount) {\n    switch (auth.authType) {\n        case AuthType.Standard:\n            const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), { fee: intToBigInt(amount, false) });\n            return Object.assign(Object.assign({}, auth), { spendingCondition });\n        case AuthType.Sponsored:\n            const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), { fee: intToBigInt(amount, false) });\n            return Object.assign(Object.assign({}, auth), { sponsorSpendingCondition });\n    }\n}\nexport function getFee(auth) {\n    switch (auth.authType) {\n        case AuthType.Standard:\n            return auth.spendingCondition.fee;\n        case AuthType.Sponsored:\n            return auth.sponsorSpendingCondition.fee;\n    }\n}\nexport function setNonce(auth, nonce) {\n    const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), { nonce: intToBigInt(nonce, false) });\n    return Object.assign(Object.assign({}, auth), { spendingCondition });\n}\nexport function setSponsorNonce(auth, nonce) {\n    const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), { nonce: intToBigInt(nonce, false) });\n    return Object.assign(Object.assign({}, auth), { sponsorSpendingCondition });\n}\nexport function setSponsor(auth, sponsorSpendingCondition) {\n    const sc = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: intToBigInt(sponsorSpendingCondition.nonce, false), fee: intToBigInt(sponsorSpendingCondition.fee, false) });\n    return Object.assign(Object.assign({}, auth), { sponsorSpendingCondition: sc });\n}\nexport function serializeAuthorization(auth) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(auth.authType);\n    switch (auth.authType) {\n        case AuthType.Standard:\n            bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n            break;\n        case AuthType.Sponsored:\n            bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n            bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializeAuthorization(bufferReader) {\n    const authType = bufferReader.readUInt8Enum(AuthType, n => {\n        throw new DeserializationError(`Could not parse ${n} as AuthType`);\n    });\n    let spendingCondition;\n    switch (authType) {\n        case AuthType.Standard:\n            spendingCondition = deserializeSpendingCondition(bufferReader);\n            return createStandardAuth(spendingCondition);\n        case AuthType.Sponsored:\n            spendingCondition = deserializeSpendingCondition(bufferReader);\n            const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n            return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n    }\n}\n//# sourceMappingURL=authorization.js.map"]},"metadata":{},"sourceType":"module"}