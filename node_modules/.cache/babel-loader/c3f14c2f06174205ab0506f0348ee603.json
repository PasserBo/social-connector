{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar bufferutils_1 = require('./bufferutils');\n\nvar bcrypto = require('./crypto');\n\nvar transaction_1 = require('./transaction');\n\nvar types = require('./types');\n\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\n\nvar typeforce = require('typeforce');\n\nvar varuint = require('varuint-bitcoin');\n\nvar errorMerkleNoTxes = new TypeError('Cannot compute merkle root for zero transactions');\nvar errorWitnessNotSegwit = new TypeError('Cannot compute witness commit for non-segwit block');\n\nvar Block = /*#__PURE__*/function () {\n  function Block() {\n    _classCallCheck(this, Block);\n\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n\n  _createClass(Block, [{\n    key: \"getWitnessCommit\",\n    value: function getWitnessCommit() {\n      if (!txesHaveWitnessCommit(this.transactions)) return null; // The merkle root for the witness data is in an OP_RETURN output.\n      // There is no rule for the index of the output, so use filter to find it.\n      // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n      // If multiple commits are found, the output with highest index is assumed.\n\n      var witnessCommits = this.transactions[0].outs.filter(function (out) {\n        return out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex'));\n      }).map(function (out) {\n        return out.script.slice(6, 38);\n      });\n      if (witnessCommits.length === 0) return null; // Use the commit with the highest output (should only be one though)\n\n      var result = witnessCommits[witnessCommits.length - 1];\n      if (!(result instanceof Buffer && result.length === 32)) return null;\n      return result;\n    }\n  }, {\n    key: \"hasWitnessCommit\",\n    value: function hasWitnessCommit() {\n      if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32) return true;\n      if (this.getWitnessCommit() !== null) return true;\n      return false;\n    }\n  }, {\n    key: \"hasWitness\",\n    value: function hasWitness() {\n      return anyTxHasWitness(this.transactions);\n    }\n  }, {\n    key: \"weight\",\n    value: function weight() {\n      var base = this.byteLength(false, false);\n      var total = this.byteLength(false, true);\n      return base * 3 + total;\n    }\n  }, {\n    key: \"byteLength\",\n    value: function byteLength(headersOnly) {\n      var allowWitness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (headersOnly || !this.transactions) return 80;\n      return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n        return a + x.byteLength(allowWitness);\n      }, 0);\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return bcrypto.hash256(this.toBuffer(true));\n    }\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n    }\n  }, {\n    key: \"getUTCDate\",\n    value: function getUTCDate() {\n      var date = new Date(0); // epoch\n\n      date.setUTCSeconds(this.timestamp);\n      return date;\n    } // TODO: buffer, offset compatibility\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer(headersOnly) {\n      var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n      var bufferWriter = new bufferutils_1.BufferWriter(buffer);\n      bufferWriter.writeInt32(this.version);\n      bufferWriter.writeSlice(this.prevHash);\n      bufferWriter.writeSlice(this.merkleRoot);\n      bufferWriter.writeUInt32(this.timestamp);\n      bufferWriter.writeUInt32(this.bits);\n      bufferWriter.writeUInt32(this.nonce);\n      if (headersOnly || !this.transactions) return buffer;\n      varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n      bufferWriter.offset += varuint.encode.bytes;\n      this.transactions.forEach(function (tx) {\n        var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n        tx.toBuffer(buffer, bufferWriter.offset);\n        bufferWriter.offset += txSize;\n      });\n      return buffer;\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex(headersOnly) {\n      return this.toBuffer(headersOnly).toString('hex');\n    }\n  }, {\n    key: \"checkTxRoots\",\n    value: function checkTxRoots() {\n      // If the Block has segwit transactions but no witness commit,\n      // there's no way it can be valid, so fail the check.\n      var hasWitnessCommit = this.hasWitnessCommit();\n      if (!hasWitnessCommit && this.hasWitness()) return false;\n      return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);\n    }\n  }, {\n    key: \"checkProofOfWork\",\n    value: function checkProofOfWork() {\n      var hash = bufferutils_1.reverseBuffer(this.getHash());\n      var target = Block.calculateTarget(this.bits);\n      return hash.compare(target) <= 0;\n    }\n  }, {\n    key: \"__checkMerkleRoot\",\n    value: function __checkMerkleRoot() {\n      if (!this.transactions) throw errorMerkleNoTxes;\n      var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n      return this.merkleRoot.compare(actualMerkleRoot) === 0;\n    }\n  }, {\n    key: \"__checkWitnessCommit\",\n    value: function __checkWitnessCommit() {\n      if (!this.transactions) throw errorMerkleNoTxes;\n      if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n      var actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);\n      return this.witnessCommit.compare(actualWitnessCommit) === 0;\n    }\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n      var bufferReader = new bufferutils_1.BufferReader(buffer);\n      var block = new Block();\n      block.version = bufferReader.readInt32();\n      block.prevHash = bufferReader.readSlice(32);\n      block.merkleRoot = bufferReader.readSlice(32);\n      block.timestamp = bufferReader.readUInt32();\n      block.bits = bufferReader.readUInt32();\n      block.nonce = bufferReader.readUInt32();\n      if (buffer.length === 80) return block;\n\n      var readTransaction = function readTransaction() {\n        var tx = transaction_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset), true);\n        bufferReader.offset += tx.byteLength();\n        return tx;\n      };\n\n      var nTransactions = bufferReader.readVarInt();\n      block.transactions = [];\n\n      for (var i = 0; i < nTransactions; ++i) {\n        var tx = readTransaction();\n        block.transactions.push(tx);\n      }\n\n      var witnessCommit = block.getWitnessCommit(); // This Block contains a witness commit\n\n      if (witnessCommit) block.witnessCommit = witnessCommit;\n      return block;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return Block.fromBuffer(Buffer.from(hex, 'hex'));\n    }\n  }, {\n    key: \"calculateTarget\",\n    value: function calculateTarget(bits) {\n      var exponent = ((bits & 0xff000000) >> 24) - 3;\n      var mantissa = bits & 0x007fffff;\n      var target = Buffer.alloc(32, 0);\n      target.writeUIntBE(mantissa, 29 - exponent, 3);\n      return target;\n    }\n  }, {\n    key: \"calculateMerkleRoot\",\n    value: function calculateMerkleRoot(transactions, forWitness) {\n      typeforce([{\n        getHash: types.Function\n      }], transactions);\n      if (transactions.length === 0) throw errorMerkleNoTxes;\n      if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;\n      var hashes = transactions.map(function (transaction) {\n        return transaction.getHash(forWitness);\n      });\n      var rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n      return forWitness ? bcrypto.hash256(Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])) : rootHash;\n    }\n  }]);\n\n  return Block;\n}();\n\nexports.Block = Block;\n\nfunction txesHaveWitnessCommit(transactions) {\n  return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;\n}\n\nfunction anyTxHasWitness(transactions) {\n  return transactions instanceof Array && transactions.some(function (tx) {\n    return typeof tx === 'object' && tx.ins instanceof Array && tx.ins.some(function (input) {\n      return typeof input === 'object' && input.witness instanceof Array && input.witness.length > 0;\n    });\n  });\n}","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bitcoinjs-lib/src/block.js"],"names":["Object","defineProperty","exports","value","bufferutils_1","require","bcrypto","transaction_1","types","fastMerkleRoot","typeforce","varuint","errorMerkleNoTxes","TypeError","errorWitnessNotSegwit","Block","version","prevHash","undefined","merkleRoot","timestamp","witnessCommit","bits","nonce","transactions","txesHaveWitnessCommit","witnessCommits","outs","filter","out","script","slice","equals","Buffer","from","map","length","result","getWitnessCommit","anyTxHasWitness","base","byteLength","total","headersOnly","allowWitness","encodingLength","reduce","a","x","hash256","toBuffer","reverseBuffer","getHash","toString","date","Date","setUTCSeconds","buffer","allocUnsafe","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","encode","offset","bytes","forEach","tx","txSize","hasWitnessCommit","hasWitness","__checkMerkleRoot","__checkWitnessCommit","hash","target","calculateTarget","compare","actualMerkleRoot","calculateMerkleRoot","actualWitnessCommit","Error","bufferReader","BufferReader","block","readInt32","readSlice","readUInt32","readTransaction","Transaction","fromBuffer","nTransactions","readVarInt","i","push","hex","exponent","mantissa","alloc","writeUIntBE","forWitness","Function","hashes","transaction","rootHash","concat","ins","witness","Array","some","input"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n"]},"metadata":{},"sourceType":"script"}