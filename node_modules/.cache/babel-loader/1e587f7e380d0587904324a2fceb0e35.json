{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar convert = require('../converter');\n\nvar tools_1 = require('../converter/tools');\n\nfunction psbtToBuffer(_ref) {\n  var globalMap = _ref.globalMap,\n      inputs = _ref.inputs,\n      outputs = _ref.outputs;\n\n  var _psbtToKeyVals = psbtToKeyVals({\n    globalMap: globalMap,\n    inputs: inputs,\n    outputs: outputs\n  }),\n      globalKeyVals = _psbtToKeyVals.globalKeyVals,\n      inputKeyVals = _psbtToKeyVals.inputKeyVals,\n      outputKeyVals = _psbtToKeyVals.outputKeyVals;\n\n  var globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n\n  var keyValsOrEmptyToBuffer = function keyValsOrEmptyToBuffer(keyVals) {\n    return keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);\n  };\n\n  var inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  var outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  var header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat([header, globalBuffer].concat(inputBuffers, outputBuffers));\n}\n\nexports.psbtToBuffer = psbtToBuffer;\n\nvar sortKeyVals = function sortKeyVals(a, b) {\n  return a.key.compare(b.key);\n};\n\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  var keyHexSet = new Set();\n  var keyVals = Object.entries(keyValMap).reduce(function (result, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    if (key === 'unknownKeyVals') return result; // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n\n    var converter = converterFactory[key];\n    if (converter === undefined) return result;\n    var encodedKeyVals = (Array.isArray(value) ? value : [value]).map(converter.encode);\n    var keyHexes = encodedKeyVals.map(function (kv) {\n      return kv.key.toString('hex');\n    });\n    keyHexes.forEach(function (hex) {\n      if (keyHexSet.has(hex)) throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []); // Get other keyVals that have not yet been gotten\n\n  var otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter(function (keyVal) {\n    return !keyHexSet.has(keyVal.key.toString('hex'));\n  }) : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\n\nfunction psbtToKeyVals(_ref4) {\n  var globalMap = _ref4.globalMap,\n      inputs = _ref4.inputs,\n      outputs = _ref4.outputs;\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(function (i) {\n      return keyValsFromMap(i, convert.inputs);\n    }),\n    outputKeyVals: outputs.map(function (o) {\n      return keyValsFromMap(o, convert.outputs);\n    })\n  };\n}\n\nexports.psbtToKeyVals = psbtToKeyVals;","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bip174/src/lib/parser/toBuffer.js"],"names":["Object","defineProperty","exports","value","convert","require","tools_1","psbtToBuffer","globalMap","inputs","outputs","psbtToKeyVals","globalKeyVals","inputKeyVals","outputKeyVals","globalBuffer","keyValsToBuffer","keyValsOrEmptyToBuffer","keyVals","length","Buffer","from","map","inputBuffers","outputBuffers","header","allocUnsafe","writeUIntBE","concat","sortKeyVals","a","b","key","compare","keyValsFromMap","keyValMap","converterFactory","keyHexSet","Set","entries","reduce","result","converter","undefined","encodedKeyVals","Array","isArray","encode","keyHexes","kv","toString","forEach","hex","has","Error","add","otherKeyVals","unknownKeyVals","filter","keyVal","sort","globals","i","o"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n"]},"metadata":{},"sourceType":"script"}