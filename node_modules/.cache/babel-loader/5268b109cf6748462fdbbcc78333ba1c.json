{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\n\nvar errors_1 = require(\"../errors\");\n\nvar SECP256K1Client = /*#__PURE__*/function () {\n  function SECP256K1Client() {\n    _classCallCheck(this, SECP256K1Client);\n  }\n\n  _createClass(SECP256K1Client, null, [{\n    key: \"loadPrivateKey\",\n    value: function loadPrivateKey(rawPrivateKey) {\n      if (rawPrivateKey.length === 66) {\n        rawPrivateKey = rawPrivateKey.slice(0, 64);\n      }\n\n      return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n  }, {\n    key: \"loadPublicKey\",\n    value: function loadPublicKey(rawPublicKey) {\n      return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n  }, {\n    key: \"derivePublicKey\",\n    value: function derivePublicKey(privateKey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (typeof privateKey !== 'string') {\n        throw Error('private key must be a string');\n      }\n\n      if (!/^[0-9A-F]+$/i.test(privateKey)) {\n        throw Error('private key must be a hex string');\n      }\n\n      if (privateKey.length == 66) {\n        privateKey = privateKey.slice(0, 64);\n      } else if (privateKey.length <= 64) {// do nothing\n      } else {\n        throw Error('private key must be 66 characters or less');\n      }\n\n      var keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n      return keypair.getPublic(compressed, 'hex');\n    }\n  }, {\n    key: \"signHash\",\n    value: function signHash(signingInputHash, rawPrivateKey) {\n      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose';\n\n      // make sure the required parameters are provided\n      if (!(signingInputHash && rawPrivateKey)) {\n        throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n      } // prepare the private key\n\n\n      var privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey); // calculate the signature\n\n      var signatureObject = privateKeyObject.sign(signingInputHash);\n      var derSignature = Buffer.from(signatureObject.toDER());\n\n      if (format === 'der') {\n        return derSignature.toString('hex');\n      } else if (format === 'jose') {\n        // return the JOSE-formatted signature\n        return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n      } else {\n        throw Error('Invalid signature format');\n      }\n    }\n  }, {\n    key: \"loadSignature\",\n    value: function loadSignature(joseSignature) {\n      // create and return the DER-formatted signature buffer\n      return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n    }\n  }, {\n    key: \"verifyHash\",\n    value: function verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n      // make sure the required parameters are provided\n      if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n        throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n      } // prepare the public key\n\n\n      var publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey); // verify the token\n\n      return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n  }]);\n\n  return SECP256K1Client;\n}();\n\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';","map":{"version":3,"sources":["cryptoClients/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\nconst errors_1 = require(\"../errors\");\nclass SECP256K1Client {\n    constructor() {\n    }\n    static loadPrivateKey(rawPrivateKey) {\n        if (rawPrivateKey.length === 66) {\n            rawPrivateKey = rawPrivateKey.slice(0, 64);\n        }\n        return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n    static loadPublicKey(rawPublicKey) {\n        return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n    static derivePublicKey(privateKey, compressed = true) {\n        if (typeof privateKey !== 'string') {\n            throw Error('private key must be a string');\n        }\n        if (!(/^[0-9A-F]+$/i.test(privateKey))) {\n            throw Error('private key must be a hex string');\n        }\n        if (privateKey.length == 66) {\n            privateKey = privateKey.slice(0, 64);\n        }\n        else if (privateKey.length <= 64) {\n            // do nothing\n        }\n        else {\n            throw Error('private key must be 66 characters or less');\n        }\n        const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n        return keypair.getPublic(compressed, 'hex');\n    }\n    static signHash(signingInputHash, rawPrivateKey, format = 'jose') {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n        }\n        // prepare the private key\n        const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey);\n        // calculate the signature\n        const signatureObject = privateKeyObject.sign(signingInputHash);\n        const derSignature = Buffer.from(signatureObject.toDER());\n        if (format === 'der') {\n            return derSignature.toString('hex');\n        }\n        else if (format === 'jose') {\n            // return the JOSE-formatted signature\n            return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n        }\n        else {\n            throw Error('Invalid signature format');\n        }\n    }\n    static loadSignature(joseSignature) {\n        // create and return the DER-formatted signature buffer\n        return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n    }\n    static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n        }\n        // prepare the public key\n        const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey);\n        // verify the token\n        return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n}\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';\n//# sourceMappingURL=secp256k1.js.map"]},"metadata":{},"sourceType":"script"}