{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar parser_1 = require('../parser');\n\nfunction combine(psbts) {\n  var self = psbts[0];\n  var selfKeyVals = parser_1.psbtToKeyVals(self);\n  var others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  var selfTx = getTx(self);\n\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n\n  var selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  var selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  var selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n\n  var _iterator = _createForOfIteratorHelper(others),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var other = _step.value;\n      var otherTx = getTx(other);\n\n      if (otherTx === undefined || !otherTx.toBuffer().equals(selfTx.toBuffer())) {\n        throw new Error('Combine: One of the Psbts does not have the same transaction.');\n      }\n\n      var otherKeyVals = parser_1.psbtToKeyVals(other);\n      var otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n      otherGlobalSet.forEach(keyPusher(selfGlobalSet, selfKeyVals.globalKeyVals, otherKeyVals.globalKeyVals));\n      var otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n      otherInputSets.forEach(function (inputSet, idx) {\n        return inputSet.forEach(keyPusher(selfInputSets[idx], selfKeyVals.inputKeyVals[idx], otherKeyVals.inputKeyVals[idx]));\n      });\n      var otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n      otherOutputSets.forEach(function (outputSet, idx) {\n        return outputSet.forEach(keyPusher(selfOutputSets[idx], selfKeyVals.outputKeyVals[idx], otherKeyVals.outputKeyVals[idx]));\n      });\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals\n  });\n}\n\nexports.combine = combine;\n\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return function (key) {\n    if (selfSet.has(key)) return;\n    var newKv = otherKeyVals.filter(function (kv) {\n      return kv.key.toString('hex') === key;\n    })[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\n\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\n\nfunction getKeySet(keyVals) {\n  var set = new Set();\n  keyVals.forEach(function (keyVal) {\n    var hex = keyVal.key.toString('hex');\n    if (set.has(hex)) throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bip174/src/lib/combiner/index.js"],"names":["Object","defineProperty","exports","value","parser_1","require","combine","psbts","self","selfKeyVals","psbtToKeyVals","others","slice","length","Error","selfTx","getTx","undefined","selfGlobalSet","getKeySet","globalKeyVals","selfInputSets","inputKeyVals","map","selfOutputSets","outputKeyVals","other","otherTx","toBuffer","equals","otherKeyVals","otherGlobalSet","forEach","keyPusher","otherInputSets","inputSet","idx","otherOutputSets","outputSet","psbtFromKeyVals","globalMapKeyVals","selfSet","key","has","newKv","filter","kv","toString","push","add","psbt","globalMap","unsignedTx","keyVals","set","Set","keyVal","hex"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n"]},"metadata":{},"sourceType":"script"}