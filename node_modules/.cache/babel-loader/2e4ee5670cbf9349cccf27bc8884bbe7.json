{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport React__default from 'react';\nvar _window = undefined;\n\ntry {\n  _window = window;\n} catch (e) {}\n\nfunction getWindow(node) {\n  var _node$ownerDocument$d, _node$ownerDocument;\n\n  return (_node$ownerDocument$d = node === null || node === void 0 ? void 0 : (_node$ownerDocument = node.ownerDocument) === null || _node$ownerDocument === void 0 ? void 0 : _node$ownerDocument.defaultView) !== null && _node$ownerDocument$d !== void 0 ? _node$ownerDocument$d : _window;\n}\n\nfunction checkIsBrowser() {\n  var _window = getWindow();\n\n  return Boolean(typeof _window !== 'undefined' && _window.document && _window.document.createElement);\n}\n\nvar isBrowser = /*#__PURE__*/checkIsBrowser();\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction createContext(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? true : _options$strict,\n      _options$errorMessage = _options.errorMessage,\n      errorMessage = _options$errorMessage === void 0 ? 'useContext must be inside a Provider with a value' : _options$errorMessage,\n      name = _options.name;\n  var Context = React__default.createContext(undefined);\n  Context.displayName = name;\n\n  function useContext() {\n    var context = React__default.useContext(Context);\n    if (!context && strict) throw new Error(errorMessage);\n    return context;\n  }\n\n  return [Context.Provider, useContext, Context];\n}\n\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (isFunction(ref)) {\n    ref(value);\n    return;\n  }\n\n  try {\n    ref.current = value;\n  } catch (error) {\n    throw new Error(\"Cannot assign value '\" + value + \"' to ref '\" + ref + \"'\");\n  }\n}\n\nfunction mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    refs.forEach(function (ref) {\n      return assignRef(ref, value);\n    });\n  };\n}\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nfunction runIfFn(valueOrFn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return isFunction(valueOrFn) ? valueOrFn.apply(void 0, args) : valueOrFn;\n}\n\nfunction warn(options) {\n  if (options.condition && __DEV__) {\n    console.warn(options.message);\n  }\n}\n\nfunction callAllHandlers() {\n  for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    fns[_key3] = arguments[_key3];\n  }\n\n  return function (event) {\n    fns.some(function (fn) {\n      fn && fn(event);\n      return event && event.defaultPrevented;\n    });\n  };\n}\n\nfunction isString(value) {\n  return Object.prototype.toString.call(value) === '[object String]';\n}\n\nfunction omit(object, keys) {\n  var result = {};\n\n  for (var key in object) {\n    if (keys.includes(key)) continue;\n    result[key] = object[key];\n  }\n\n  return result;\n}\n\nfunction pick(object, keys) {\n  var result = {};\n\n  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n    var key = _step.value;\n\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n\n  return result;\n}\n\nvar startPad = function startPad(n, z, s) {\n  if (z === void 0) {\n    z = 2;\n  }\n\n  if (s === void 0) {\n    s = '0';\n  }\n\n  return (n + '').length <= z ? ['', '-'][+(n < 0)] + (s.repeat(z) + Math.abs(n)).slice(-1 * z) : n + '';\n};\n\nexport { __DEV__, assignRef, callAllHandlers, createContext, getWindow, isBrowser, isFunction, isString, mergeRefs, omit, pick, runIfFn, startPad, warn };","map":{"version":3,"sources":["../../src/utils/index.tsx"],"names":["_window","getWindow","node","Boolean","isBrowser","checkIsBrowser","isFunction","value","createContext","options","strict","errorMessage","name","Context","React","context","assignRef","ref","mergeRefs","refs","__DEV__","process","runIfFn","valueOrFn","args","warn","console","callAllHandlers","fns","fn","event","isString","Object","omit","object","keys","result","pick","key","startPad","z","s","n","Math"],"mappings":"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","sourcesContent":["import React from 'react';\n\nlet _window: Window | undefined = undefined;\n\n// Note: Accessing \"window\" in IE11 is somewhat expensive, and calling \"typeof window\"\n// hits a memory leak, whereas aliasing it and calling \"typeof _window\" does not.\n// Caching the window value at the file scope lets us minimize the impact.\ntry {\n  _window = window;\n} catch (e) {\n  /* no-op */\n}\n\n/**\n * Helper to get the window object. The helper will make sure to use a cached variable\n * of \"window\", to avoid overhead and memory leaks in IE11.\n */\nexport function getWindow(node?: HTMLElement | null): Window | undefined {\n  return node?.ownerDocument?.defaultView ?? _window;\n}\n\n/**\n * Check if we can use the DOM. Useful for SSR purposes\n */\nfunction checkIsBrowser() {\n  const _window = getWindow();\n  return Boolean(\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    typeof _window !== 'undefined' && _window.document && _window.document.createElement\n  );\n}\n\nexport const isBrowser = checkIsBrowser();\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n\nexport interface CreateContextOptions {\n  /**\n   * If `true`, React will throw if context is `null` or `undefined`\n   * In some cases, you might want to support nested context, so you can set it to `false`\n   */\n  strict?: boolean;\n  /**\n   * Error message to throw if the context is `undefined`\n   */\n  errorMessage?: string;\n  /**\n   * The display name of the context\n   */\n  name?: string;\n}\n\ntype CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>];\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nexport function createContext<ContextType>(options: CreateContextOptions = {}) {\n  const {\n    strict = true,\n    errorMessage = 'useContext must be inside a Provider with a value',\n    name,\n  } = options;\n\n  const Context = React.createContext<ContextType | undefined>(undefined);\n\n  Context.displayName = name;\n\n  function useContext() {\n    const context = React.useContext(Context);\n    if (!context && strict) throw new Error(errorMessage);\n    return context;\n  }\n\n  return [Context.Provider, useContext, Context] as CreateContextReturn<ContextType>;\n}\n\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\nexport function getValidChildren(children: React.ReactNode) {\n  return React.Children.toArray(children).filter(child =>\n    React.isValidElement(child)\n  ) as React.ReactElement[];\n}\n\ntype ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>;\n\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return;\n\n  if (isFunction(ref)) {\n    ref(value);\n    return;\n  }\n\n  try {\n    (ref as React.MutableRefObject<T>).current = value;\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);\n  }\n}\n\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\nexport function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return (value: T) => {\n    refs.forEach(ref => assignRef(ref, value));\n  };\n}\n\nexport function genId(prefix: string) {\n  return `${prefix}-${Math.random().toString(32).substr(2, 8)}`;\n}\n\nexport const makeId = (id: string, index: number) => `${id}:${index}`;\n\nconst focusableElList = [\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'embed',\n  'iframe',\n  'input:not([disabled])',\n  'object',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  '*[tabindex]:not([aria-disabled])',\n  '*[contenteditable]',\n];\n\nconst focusableElSelector = focusableElList.join();\n\nexport function getFocusables(element: HTMLElement, keyboardOnly = false) {\n  let focusableEls = Array.from(element.querySelectorAll(focusableElSelector));\n\n  // filter out elements with display: none\n  focusableEls = focusableEls.filter(\n    focusableEl => window.getComputedStyle(focusableEl).display !== 'none'\n  );\n\n  if (keyboardOnly) {\n    focusableEls = focusableEls.filter(\n      focusableEl => focusableEl.getAttribute('tabindex') !== '-1'\n    );\n  }\n\n  return focusableEls;\n}\n\n/// Evaluate color in theme object\n\nconst colorKeyInTheme = (theme: any, color: string) => color in theme.colors;\n\nconst colorHueValue = (theme: any, color: string) => {\n  const hasDot = color.search('.') !== -1;\n  if (hasDot) {\n    const [colorName, hue] = color.split('.');\n\n    if (colorKeyInTheme(theme, colorName)) {\n      return theme.colors[colorName][hue];\n    }\n  }\n  return null;\n};\n\nexport const getColorInTheme = (theme: any, color: string) => {\n  if (colorKeyInTheme(theme, color)) {\n    return theme.colors[color][500];\n  }\n\n  if (colorHueValue(theme, color)) {\n    return colorHueValue(theme, color);\n  }\n\n  return color;\n};\n\nexport const __DEV__ = process.env.NODE_ENV !== 'production';\n\nexport function runIfFn<T, U>(valueOrFn: T | ((...args: U[]) => T), ...args: U[]): T {\n  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;\n}\n\nexport function warn(options: { condition: boolean; message: string }) {\n  if (options.condition && __DEV__) {\n    console.warn(options.message);\n  }\n}\n\nexport function error(options: { condition: boolean; message: string }) {\n  if (options.condition && __DEV__) {\n    console.error(options.message);\n  }\n}\n\nexport type FunctionArguments<T extends Function> = T extends (...args: infer R) => any ? R : never;\n\nexport function callAllHandlers<T extends (event: any) => void>(...fns: (T | undefined)[]) {\n  return function (event: FunctionArguments<T>[0]) {\n    fns.some(fn => {\n      fn && fn(event);\n      return event && event.defaultPrevented;\n    });\n  };\n}\n\nexport type Merge<T1, T2> = Omit<T1, Extract<keyof T1, keyof T2>> & T2;\n\nexport type SafeMerge<T, P> = P & Omit<T, keyof P>;\n\nexport type UnionStringArray<T extends Readonly<string[]>> = T[number];\n\nexport type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\n\nexport type As<P = any> = React.ReactType<P>;\n\nexport type AnyFunction<T = any> = (...args: T[]) => any;\n\nexport type Dict<T = any> = Record<string, T>;\n\nexport type ReactNodeOrRenderProp<P> = React.ReactNode | ((props: P) => React.ReactNode);\n\nexport type Booleanish = boolean | 'true' | 'false';\n\nexport type ObjectOrArray<T, K extends keyof any = keyof any> = T[] | Record<K, T>;\n\nexport type StringOrNumber = string | number;\n\n// Number assertions\nexport function isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nexport const isNotNumber = (value: any) =>\n  typeof value !== 'number' || isNaN(value) || !isFinite(value);\n\nexport function isNumeric(value: any) {\n  return value != null && value - parseFloat(value) + 1 >= 0;\n}\n\n// Array assertions\nexport function isArray<T>(value: any): value is T[] {\n  return Array.isArray(value);\n}\n\nexport const isEmptyArray = (value: any) => isArray(value) && value.length === 0;\n\n// Generic assertions\nexport const isDefined = (value: any) => typeof value !== 'undefined' && value !== undefined;\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === 'undefined' || value === undefined;\n\n// Object assertions\nexport const isObject = (value: any): value is Dict => {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function') && !isArray(value);\n};\n\nexport const isEmptyObject = (value: any) => isObject(value) && Object.keys(value).length === 0;\n\nexport const isNull = (value: any): value is null => value == null;\n\n// String assertions\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === '[object String]';\n}\n\n// Empty assertions\nexport const isEmpty = (value: any) => {\n  if (isArray(value)) return isEmptyArray(value);\n  if (isObject(value)) return isEmptyObject(value);\n  return value == null || value === '';\n};\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {};\n\n  for (const key in object) {\n    if (keys.includes(key as any)) continue;\n    result[key] = object[key];\n  }\n\n  return result as Omit<T, K>;\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] };\n  for (const key of keys) {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {};\n  const omitted: Dict = {};\n\n  for (const key in object) {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  }\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>];\n}\n\n/**\n * Get value from a deeply nested object using a string path\n * @param obj - the object\n * @param path - the string path\n * @param fallback\n * @param index\n */\nexport function get(obj: any, path: string | number, fallback?: any, index?: number) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n  //@ts-ignore\n  path = (path?.split?.('.') ?? [path]) as string;\n  for (index = 0; index < path.length; index++) {\n    obj = obj ? obj[path[index]] : undefined;\n  }\n  return obj === undefined ? fallback : obj;\n}\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return get(scale, path, path);\n}\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map(mapper);\n  }\n\n  if (isObject(prop)) {\n    return Object.keys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key]);\n      return result;\n    }, {});\n  }\n\n  if (prop != null) {\n    return mapper(prop);\n  }\n\n  return null;\n}\n\nexport const startPad = (n: number, z = 2, s = '0') =>\n  (n + '').length <= z ? ['', '-'][+(n < 0)] + (s.repeat(z) + Math.abs(n)).slice(-1 * z) : n + '';\n"]},"metadata":{},"sourceType":"module"}