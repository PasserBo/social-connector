{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar types = require('./types');\n\nvar typeforce = require('typeforce');\n\nvar varuint = require('varuint-bitcoin'); // https://github.com/feross/buffer/blob/master/index.js#L1127\n\n\nfunction verifuint(value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component');\n}\n\nfunction readUInt64LE(buffer, offset) {\n  var a = buffer.readUInt32LE(offset);\n  var b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\n\nexports.readUInt64LE = readUInt64LE;\n\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\n\nexports.writeUInt64LE = writeUInt64LE;\n\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  var j = buffer.length - 1;\n  var tmp = 0;\n\n  for (var i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n\n  return buffer;\n}\n\nexports.reverseBuffer = reverseBuffer;\n\nfunction cloneBuffer(buffer) {\n  var clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\n\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\n\nvar BufferWriter = /*#__PURE__*/function () {\n  function BufferWriter(buffer) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, BufferWriter);\n\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  _createClass(BufferWriter, [{\n    key: \"writeUInt8\",\n    value: function writeUInt8(i) {\n      this.offset = this.buffer.writeUInt8(i, this.offset);\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(i) {\n      this.offset = this.buffer.writeInt32LE(i, this.offset);\n    }\n  }, {\n    key: \"writeUInt32\",\n    value: function writeUInt32(i) {\n      this.offset = this.buffer.writeUInt32LE(i, this.offset);\n    }\n  }, {\n    key: \"writeUInt64\",\n    value: function writeUInt64(i) {\n      this.offset = writeUInt64LE(this.buffer, i, this.offset);\n    }\n  }, {\n    key: \"writeVarInt\",\n    value: function writeVarInt(i) {\n      varuint.encode(i, this.buffer, this.offset);\n      this.offset += varuint.encode.bytes;\n    }\n  }, {\n    key: \"writeSlice\",\n    value: function writeSlice(slice) {\n      if (this.buffer.length < this.offset + slice.length) {\n        throw new Error('Cannot write slice out of bounds');\n      }\n\n      this.offset += slice.copy(this.buffer, this.offset);\n    }\n  }, {\n    key: \"writeVarSlice\",\n    value: function writeVarSlice(slice) {\n      this.writeVarInt(slice.length);\n      this.writeSlice(slice);\n    }\n  }, {\n    key: \"writeVector\",\n    value: function writeVector(vector) {\n      var _this = this;\n\n      this.writeVarInt(vector.length);\n      vector.forEach(function (buf) {\n        return _this.writeVarSlice(buf);\n      });\n    }\n  }]);\n\n  return BufferWriter;\n}();\n\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\n\nvar BufferReader = /*#__PURE__*/function () {\n  function BufferReader(buffer) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, BufferReader);\n\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  _createClass(BufferReader, [{\n    key: \"readUInt8\",\n    value: function readUInt8() {\n      var result = this.buffer.readUInt8(this.offset);\n      this.offset++;\n      return result;\n    }\n  }, {\n    key: \"readInt32\",\n    value: function readInt32() {\n      var result = this.buffer.readInt32LE(this.offset);\n      this.offset += 4;\n      return result;\n    }\n  }, {\n    key: \"readUInt32\",\n    value: function readUInt32() {\n      var result = this.buffer.readUInt32LE(this.offset);\n      this.offset += 4;\n      return result;\n    }\n  }, {\n    key: \"readUInt64\",\n    value: function readUInt64() {\n      var result = readUInt64LE(this.buffer, this.offset);\n      this.offset += 8;\n      return result;\n    }\n  }, {\n    key: \"readVarInt\",\n    value: function readVarInt() {\n      var vi = varuint.decode(this.buffer, this.offset);\n      this.offset += varuint.decode.bytes;\n      return vi;\n    }\n  }, {\n    key: \"readSlice\",\n    value: function readSlice(n) {\n      if (this.buffer.length < this.offset + n) {\n        throw new Error('Cannot read slice out of bounds');\n      }\n\n      var result = this.buffer.slice(this.offset, this.offset + n);\n      this.offset += n;\n      return result;\n    }\n  }, {\n    key: \"readVarSlice\",\n    value: function readVarSlice() {\n      return this.readSlice(this.readVarInt());\n    }\n  }, {\n    key: \"readVector\",\n    value: function readVector() {\n      var count = this.readVarInt();\n      var vector = [];\n\n      for (var i = 0; i < count; i++) {\n        vector.push(this.readVarSlice());\n      }\n\n      return vector;\n    }\n  }]);\n\n  return BufferReader;\n}();\n\nexports.BufferReader = BufferReader;","map":{"version":3,"sources":["/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/bitcoinjs-lib/src/bufferutils.js"],"names":["Object","defineProperty","exports","value","types","require","typeforce","varuint","verifuint","max","Error","Math","floor","readUInt64LE","buffer","offset","a","readUInt32LE","b","writeUInt64LE","writeInt32LE","writeUInt32LE","reverseBuffer","length","j","tmp","i","cloneBuffer","clone","Buffer","allocUnsafe","copy","BufferWriter","tuple","UInt32","writeUInt8","encode","bytes","slice","writeVarInt","writeSlice","vector","forEach","buf","writeVarSlice","BufferReader","result","readUInt8","readInt32LE","vi","decode","n","readSlice","readVarInt","count","push","readVarSlice"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n"]},"metadata":{},"sourceType":"script"}